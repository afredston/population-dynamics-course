---
title: "Marine Population Dynamics"
subtitle: OCEA265, UC Santa Cruz
author: Alexa L. Fredston
date: Spring 2025
format: pdf
editor: visual
execute:
  echo: false
  warning: false
---

```{r setup}
library(ggplot2)
library(dplyr)
```

Alexa would like to gratefully acknowledge the following sources:

-   Alan Hastings' book, "Population Biology: Concepts and Models"
-   Hal Caswell's book, "Matrix Population Models" 
-   Nicholas J. Gotelli's book, "A Primer of Ecology"
-   Marissa Baskett's ESP121 course notes (UC Davis)
-   Dave Tilman's UCSB course ESM201, for which Alexa was a TA
-   chatGPT, which generated a lot of the Quarto code for the math.

# Welcome

Introduce yourselves:

-   Your preferred name
-   What you do at UCSC (your position, research, etc.)

# Introduction to population modeling

## What models are

\textcolor{green}{Reflect individually:} What do you think models are? What comes to mind with that word?

Classes of models:

-   Static (e.g., linear regression) *vs.* dynamic (time is a variable; differential or difference equations describe system evolution over time)
-   Discrete *vs.* continuous (is any biological data ever in continuous time?)
-   Statistical / phenomenological *vs.* theoretical / mechanistic / process-based
-   Stochastic (incorporates randomness) *vs.* deterministic (get the same outcome every time)

## Structure and content of this class

### Structure and content

-   The course textbook is Population Biology: Concepts and Methods (Hastings, 2nd edition).
-   We meet weekly to work through the math of biological models by hand. I suggest taking notes in a notebook or using a tablet and pencil. You can also generate notes like the ones I'm using with LaTeX (see overleaf.com) or Quarto (see posit.co). Classes will be a mix of lecture and in-class activities, with lots of breaks.
-   Problem sets ask you to explore fitting the models we learned to data. You can do this in any software you like. This course is intentionally software-agnostic to allow you to practice skills in whatever language or interface you use in your own research.
-   Review grading policy, the rest of the [syllabus](https://docs.google.com/document/d/13uDEevusyg55NbJjcye-7ScDaJNzR70pEIcCSM0tEYY/edit?tab=t.0), and introduce the [course repo on GitHub](https://github.com/afredston/population-dynamics-course).

## On math anxiety

-   "A feeling of tension, apprehension, or fear that interferes with math performance" (Ashcroft, 2002)
-   Math can initiate physiological responses including increased heart rate and cortisol levels, and neural activations analogous to those from physical pain (Ramirez *et al.,* 2018)
-   These responses are also associated with lower math performance, probably because the person is dividing their working memory between the math problem and anxiety-associated thoughts (e.g., about the consequences of failure) (Ramirez *et al.,* 2018)
-   Math anxiety is extremely common in higher education and is not a binary classification; many students have some degree of math anxiety (Ramirez *et al.,* 2018)
-   Socioenvironmental factors are a primary driver of math anxiety, including home experiences (parental involvement in schooling), exposure to negative framings ("math is confusing", "I always hated math"), negative classroom experiences (often associated with teachers who also have math anxiety) or assessment outcomes, and students' "self-concept" (Ramirez *et al.,* 2018)

## Calculus refresher

(Drafted by chatGPT, edited by Alexa)

### Differentiation

Let's say we have some function that looks like this:

```{r derivatives}
f <- function(x) x^2 * exp(-x)

dat <- data.frame(x = seq(0, 5, length.out=100))
dat$fx = f(dat$x)

ggplot(dat, aes(x=x, y=fx)) +
  geom_line(aes(color="Function: f(x)")) +
  labs(color="legend",
       y="value") +
  theme_minimal()
```

We don't need to do anything to know what the value of $f(x)$ is at any $x$ on this graph; we can already figure that out.

However, we don't currently know what the **rate of change** is in $f(x)$ at any $x$ on this graph. To figure that out, we have to take the **derivative**, via "differentiation". Differentiation describes the rate of change of a function. If $f(x)$ represents a population size over time, its derivative measures the instantaneous rate of change.

We describe this mathematically using the concept of **limits**. These let us calculate the derivative at any $x$ as the slope of a line from $x$ to $x + \Delta x$. We define the derivative as the limit of this slope as $\Delta x$ goes to 0.

$$
\frac{d}{dx} f(x) = \lim_{\Delta x \to 0} \frac{f(x + \Delta x) - f(x)}{\Delta x}
$$

Let's unpack limits a little more. Limits allow us to compute the derivative at any point $x$ by considering the slope of a line connecting $x$ to $x + \Delta x$. The derivative is then defined as the limit of this slope as $\Delta x$ approaches zero. Let's explore this graphically with a secant line (a line that intersects a curve at two distinct points) and a tangent line (which touches a curve at just one point, and does not cross it).

```{r limits}

# Define function and derivative
f <- function(x) x^2 * exp(-x)
df <- function(x) (2*x - x^2) * exp(-x)

# Select a point and a small Δx
x0 <- 1
dx <- 0.5  # Try different values to show secant line changing
x1 <- x0 + dx

# Compute function values
y0 <- f(x0)
y1 <- f(x1)

# Compute secant line equation: y = m(x - x0) + y0
m_secant <- (y1 - y0) / (x1 - x0)
secant_line <- function(x) m_secant * (x - x0) + y0

# Compute tangent line equation at x0: y = f'(x0)(x - x0) + f(x0)
m_tangent <- df(x0)
tangent_line <- function(x) m_tangent * (x - x0) + y0

# Generate x values for plotting
x_vals <- seq(0, 3, length.out = 100)

# Create data frame
data <- data.frame(
  x = x_vals,
  f_x = f(x_vals),
  secant = secant_line(x_vals),
  tangent = tangent_line(x_vals)
)

# Plot function, secant, and tangent lines
ggplot(data, aes(x)) +
  geom_line(aes(y = f_x, color = "Function f(x)")) +
  geom_line(aes(y = secant, color = "Secant Line")) +
  geom_line(aes(y = tangent, color= "Tangent Line")) +
  geom_point(aes(x = x0, y = y0), color = "black", size = 3) +
  geom_point(aes(x = x1, y = y1), color = "black", size = 3) +
  labs(title = "Graphical Interpretation of Limits and Derivatives",
       y = "f(x)",
       color = "Legend") +
  theme_minimal()
```

This is a good time to remind you that this course has zero memorization! Don't worry if these terms are unfamiliar or don't stick.

Limits help us graphically understand differentiation, but they aren't always convenient for computation or calculation, because we calculate them one $x$ at a time. Thankfully rules exist to derive a general formula to compute the slope of a function at any $x$ in the function's domain. We're going to hold off on the derivatives refresher though, until it actually comes up in class; knowing the intuition behind what a derivative is will suffice for today.

<!-- ### Computing derivatives -->

<!-- Rather than simply stating the limit, let’s derive the derivative of a function from first principles. This procedure always follows the same steps: we take the difference quotient, substitute in the actual function, and try to simplify that as much as possible. This looks different for different classes of functions (polynomials, exponentials, trigonometric, etc.) ChatGPT has several key recommendations for differentiation, regardless of the function:  -->

<!-- * Always substitute $x + \Delta x$ carefully into the function. -->

<!-- *  Expand and simplify the numerator before dividing. -->

<!-- *  Factor out $\Delta x$ when possible so it cancels cleanly. -->

<!-- * Use known limits for trigonometric, exponential, and logarithmic functions. -->

<!-- #### Example: Compute the derivative of $f(x) = x^2$ -->

<!-- 1. Write the **difference quotient,** the average rate of change of a function over a small interval. (This is the same as the expression you take the limit of as $\Delta x \to 0$.) -->

<!--    $$ -->

<!--    \frac{f(x + \Delta x) - f(x)}{\Delta x} -->

<!--    $$ -->

<!-- Note that the difference quotient always follows this general form, but the actual expression varies depending on $f(x)$, because in order to compute the derivative we next...  -->

<!-- 2. **Substitute $f(x)$** in the above equation with whatever the function actually is, here, $f(x) = x^2$.  -->

<!--    $$ -->

<!--    \frac{(x + \Delta x)^2 - x^2}{\Delta x} -->

<!--    $$ -->

<!-- 3. **Expand the square:**   -->

<!--    $$ -->

<!--    \frac{x^2 + 2x\Delta x + (\Delta x)^2 - x^2}{\Delta x} -->

<!--    $$ -->

<!-- 4. **Simplify:**   -->

<!--    $$ -->

<!--    \frac{2x\Delta x + (\Delta x)^2}{\Delta x} = 2x + \Delta x -->

<!--    $$ -->

<!-- 5. **Take the limit as $\Delta x \to 0$:**   -->

<!--    $$ -->

<!--    \lim_{\Delta x \to 0} (2x + \Delta x) = 2x -->

<!--    $$ -->

<!-- Thus, $\frac{d}{dx} x^2 = 2x$. You can convince yourself this is true graphically by plotting the function and calculating the slope of a line through different points on that function.  -->

<!-- ### When to Use the Limit Definition vs. Shortcut Rules -->

<!-- While limits provide the **formal definition** of a derivative, in practice, we often use differentiation rules that simplify computation. -->

<!-- #### **When do we use limits?** -->

<!-- - When proving a derivative from scratch (e.g., showing that $\frac{d}{dx} x^2 = 2x$). -->

<!-- - When dealing with functions that don’t fit standard differentiation rules (e.g., custom-defined functions or piecewise functions). -->

<!-- - In cases where we need to rigorously justify why a function is differentiable. -->

<!-- #### **When can we use shortcut rules?** -->

<!-- - If a function follows well-known rules, we can differentiate directly: -->

<!--   - **Power Rule**: $\frac{d}{dx} x^n = n x^{n-1}$ -->

<!--   - **Product Rule**: $\frac{d}{dx} [f(x)g(x)] = f'(x) g(x) + f(x) g'(x)$ -->

<!--   - **Quotient Rule**: $\frac{d}{dx} \left(\frac{f(x)}{g(x)}\right) = \frac{f'(x) g(x) - f(x) g'(x)}{g(x)^2}$ -->

<!--   - **Chain Rule**: $\frac{d}{dx} f(g(x)) = f'(g(x)) g'(x)$ -->

<!-- For example, rather than using limits to find the derivative of $f(x) = x^3$, we can apply the **power rule** directly: -->

<!-- $$ -->

<!-- \frac{d}{dx} x^3 = 3x^2 -->

<!-- $$ -->

<!-- This is much faster than using the limit definition! -->

<!-- #### Common Derivatives -->

<!-- - Power rule: $\frac{d}{dx} x^n = n x^{n-1}$ -->

<!-- - Exponential function: $\frac{d}{dx} e^x = e^x$, $\frac{d}{dx} a^x = a^x \ln a$ -->

<!-- - Logarithmic function: $\frac{d}{dx} \ln x = \frac{1}{x}$ -->

<!-- - Chain rule: If $y = g(h(x))$, then $\frac{dy}{dx} = g'(h(x)) h'(x)$ -->

<!-- Example: The exponential growth model is defined by: -->

<!-- $$ -->

<!-- \frac{dN}{dt} = rN -->

<!-- $$ -->

<!-- where $N(t)$ is population size and $r$ is the intrinsic growth rate. -->

### Integration

Integration finds the total accumulation of a quantity. The integral of $f(x)$ over an interval $[a,b]$ is:

$$
\int_a^b f(x) \,dx
$$

#### Common Integrals

-   Power rule: $\int x^n \,dx = \frac{x^{n+1}}{n+1} + C$ (for $n \neq -1$)
-   Exponential function: $\int e^x \,dx = e^x + C$
-   Logarithmic function: $\int \frac{1}{x} \,dx = \ln |x| + C$

<!-- Example: Solving the exponential growth equation: -->

<!-- $$ -->

<!-- \int \frac{dN}{N} = \int r dt -->

<!-- $$ -->

<!-- yields the solution: -->

<!-- $$ -->

<!-- N(t) = N_0 e^{rt} -->

<!-- $$ -->

<!-- where $N_0$ is the initial population size. -->

<!-- ### Logarithms and Exponents -->

<!-- Logarithms and exponents frequently appear in population models. -->

<!-- - **Exponential functions** describe growth and decay: $N = N_0 e^{rt}$. -->

<!-- - **Logarithms** are the inverse of exponentiation: $\ln(e^x) = x$, $a^{\log_a x} = x$. -->

<!-- - **Log transformation** is often used to linearize growth models: $\ln N = \ln N_0 + rt$. -->

### Graphical interpretation

To visualize differentiation and integration, consider the function $f(x) = x^2 e^{-x}$. The derivative represents the slope at each point, while the integral gives the accumulated area under the curve.

```{r graphical-calculus}
# Load necessary library
library(ggplot2)

# Define function, derivative, and integral
f <- function(x) x^2 * exp(-x)
df <- function(x) (2*x - x^2) * exp(-x)
F_int <- function(x) -exp(-x) * (x^2 + 2*x + 2) + 2  # Indefinite integral with constant C = 2

# Generate data
x_vals <- seq(0, 5, length.out = 100)
df_vals <- df(x_vals)
F_vals <- F_int(x_vals)

# Create a dataframe for plotting
data <- data.frame(x = x_vals, f = f(x_vals), df = df_vals, F = F_vals)

# Plot function, derivative, and integral
ggplot(data, aes(x)) +
  geom_line(aes(y = f, color = "Function: f(x)")) +
  geom_line(aes(y = df, color = "Derivative: f'(x)"), linetype = "dashed") +
  geom_line(aes(y = F, color = "Integral of f(x)dx"), linetype = "dotted") +
  labs(title = "Graphical Interpretation of Differentiation and Integration",
       y = "Value",
       color = "Legend") +
  theme_minimal()
```

### BREAK

## Density-independent population growth

(Hastings pp1-16)

This is the simplest population model we can write down. It assumes that:

-   The rate of births is proportional to the number of individuals present.
-   The rate of deaths is proportional to the number of individuals present.

\textcolor{green}{Discuss:} What are the implications for this model at small population sizes? At large population sizes?

Here and forever, the population size is going to be denoted by $N$.

### The discrete time case (geometric growth)

This model has separate time steps.

When would we want to use a model like this?

-   Non-overlapping generations (e.g., seasonal insects)
-   Synchronous and distinct reproductive events (e.g., salmon, annual plants)

For now, let's ignore organisms that live for more than one time step (i.e., no age structure), and just think about something whose entire life cycle happens between $t$ and $t+1$. Note that we often think of $t$ as a year in discrete-time models, but it is actually in units of *a single generation.* This could be days, weeks, months, seasons, or many years.

**All** discrete-time models can be stated as:

$$
N_{t+1} = F(N_t)
$$ We'll spend a lot of this class talking about all the forms F can take!

The simplest form is a dimensionless coefficient:

$$
N_{t+1} = RN_t
$$ "Big R" represents the chance of survival *on average* per offspring. You can define $R=B-M$ where $B$ is the average *per capita* birth rate and $M$ is the average *per capita* death rate (mortality). Let's plot out the implications of this model for population dynamics, starting at $t=0$ with an initial population size (defined as $N_0$) of 100 and set $R=2$, with $t$ on the x-axis and $N$ on the y-axis. (This is a really common plot that we'll draw a zillion times in this course.)

![](discrete_geometric_growth.jpg)

This implies a general way to calculate population size at any time step if we know the initial population size $R_0$ and the average chance of survival per offspring, $R$:

$$
N_t = R^tN_0
$$

Based on the example above, what does this imply for population change over time if $R$ is relatively large?

What if $R=1$?

Draw it out---the population stays constant; for any $t$, if $R=1$, then $N_t = 1 \times N_0 = N_0$.

What happens if $R$ is less than 1? \textcolor{green}{Ask the students to collectively plot} this graph ($t$ *vs.* $x$) for $R=0.5$ and $N_0=1000$. We call this "geometric decay" (the case above was "geometric growth").

$N_t = R^tN_0$ is a **geometric population model**. Remember, this is a discrete-time model assuming that births and deaths are both proportional to $N$.

This model implies that:

-   If R \> 1, populations will grow unbounded.
-   If R \< 1, populations will go extinct.

Under what circumstances are those reasonable assumptions and implications in nature?

### The continuous time case (exponential growth)

Let's deal with one of those statements that is not always realistic: that generations are non-overlapping and reproduction is a discrete event. In many populations, generations are overlapping and reproduction is happening continuously.

Can you think of some examples?

-   Most microbes, including plankton
-   People

This necessitates a **continuous time model**. Because this isn't broken into time steps, rather than talking about the difference between $N_t$ and $N_{t+1}$, we'll phrase this model in terms of ${dN}/{dt}$. This is defined as the **instantaneous rate of population change**.

The simplest model of continuous-time population change is:

$$
\frac{dN}{dt} = rN
$$

There's a new term here: $r$. "Little r" is also defined as the per-capita average birth rate $b$ minus the per-capita average death rate $m$, but note that these are all lowercase letters: they're instantaneous rates. (Before they were also averaged over time within the generation $t$; that's no longer true here.) Little r is also called the *intrinsic rate of increase* or *intrinsic growth rate*.

This is a really important concept in population biology so let's spend a little more time on the intuition behind $r$. If ${dN}/{dt}$ is in units of population size / time, then dividing both sides of the equation above by N gives us $r = {dN}/{Ndt}$. Notice two things: $r$ is a *per capita* rate ($N$ is on the bottom of the equation), and the units of $r$ itself are $1 / time$. So, $r$ is telling us about the per-capita average population change over a really, really, small---instantaneous!---time step.

It would be useful to have an explicit formula for $N(t)$, and ${dN}/{dt}=rN$ is simple enough that we can actually solve it for N. Let's integrate this. Assume the initial population size is ( N(0) = N_0 ), and we want to find the population size at time ( T ), which we’ll call ( N(T) ).

First, we'll *separate the variables*---put $t$ on one side and $N$ on the other.

$$
\frac{dN}{dt} = rN
$$

Divide both sides by $N$ (assuming $N>0$):

$$
\frac{1}{N} \frac{dN}{dt} = r
$$

Now multiply both sides by $dt$:

$$
\frac{1}{N} \, dN = r \, dt
$$

Now that we've separated the variables we can integrate both sides. Remember our very brief calculus refresher? What were the common integrals, again?

-   Power rule: $\int x^n \,dx = \frac{x^{n+1}}{n+1} + C$ (for $n \neq -1$)
-   Exponential function: $\int e^x \,dx = e^x + C$
-   Logarithmic function: $\int \frac{1}{x} \,dx = \ln |x| + C$

So if we want to integrate both sides of this equation:

$$
\int_{t=0}^{t=T} \frac{1}{N} \, dN = \int_{t=0}^{t=T} r \, dt
$$

We can use the *logarithmic function* to integrate the left-hand side:

$$
\left[ \ln N(t) \right]_{t=0}^{t=T} = \ln N(T) - \ln N_0
$$

On the right-hand side, we evaluate the integral of the constant $r$ with respect to $dt$ (which integrates to a constant, $rt$) at both values of $t$. This yields:

$$
\left[ rt \right]_{t=0}^{t=T} = rT - 0 = rT
$$ (Why is the integral of any constant (like $r$) times $dt$ just that same constant times $t$? Again, let's think back to what led us to having $r \, dt$ in the derivative to begin with. We're asking, "What function has a derivative equal to a constant $r$?" And the answer to that is, it's a straight line with slope $r$, so the equation for that line is $rt$. We'll unpack this more on your homework.)

Putting the two sides back together:

$$
\ln N(T) - \ln N_0 = rT
$$

Now we want to get $N(T)$ on its own. Recall that $ln \, a - ln \, b = ln(a/b)$. In other words, the difference of two logarithms is the same as the logarithm of a quotient. So we can rewrite the above as,

$$
ln(\frac{N(T)}{N_0}) = rT 
$$ Now that we have only one logarithm we can exponentiate both sides:

$$
\frac{N(T)}{N_0} = e^{rT}
$$ or

$$
N(T) = N_0e^{rT}
$$

<!-- (Technically the right-hand side should have a $+C$. This is a constant we add in whenever we do *indefinite integrals*, which are the kind without little numbers above and below the integral---when we find the general integral rather than evaluating it between limits. It's a reminder that if the original function had a constant and we'd taken the derivative to end up with the differential equation we just integrated, we would have lost that constant in the process, because the derivative of a constant is 0.) -->

**This is the equation for exponential growth in continuous time.** We don't actually need "big T" here, since it can be evaluated at any value of $t$, so it's usually written as $N(t) = N_0e^{rt}$.

### BREAK

### Relationship between continous and discrete time (r and R)

Since it's a little harder to do exponents in your head, we won't manually calculate the population size in an exponential growth model for different values of $r$ the way we did for the discrete time case, with the exception of $r=0$. What does that evaluate to?

$$
N(t) = N_0e^0 = N_0 
$$

Here is the exponential growth curve for some other values of $r$.

```{r cont-exp}


# Parameters
N0 <- 100             # Initial population size
r_values <- c(-0.5, -0.2, 0, 0.2, 0.3)  # Growth rates to explore
T_max <- 5           # Maximum time
times <- seq(0, T_max, by = 0.1)  # Time vector

# Generate population trajectories for each r
pop_data <- expand.grid(t = times, r = r_values) %>%
  mutate(N = N0 * exp(r * t))

# Convert r to factor for cleaner labeling
pop_data$r_label <- factor(pop_data$r, labels = paste("r =", r_values))

# Plot
ggplot(pop_data, aes(x = t, y = N, color = r_label)) +
  geom_line(size = 1) +
  labs(
    title = "Exponential Growth and Decline for Different r Values",
    x = "Time (t)",
    y = "Population Size (N)",
    color = "Growth Rate"
  ) +
  theme_minimal(base_size = 14)
```

Let's think back to how this model connects to the discrete-time case. To recap, we started thinking about rates of population change in discrete time:

$$
N_{t+1} = RN_t
$$ And in continuous time:

$$
\frac{dN}{dt} = rN
$$ In both cases, we wanted to get a general equation for $N$. We were able to get this algebraically for the discrete time case:

$$
N_{t+1} = N_0R^t
$$

And we integrated the continuous-time case to get:

$$
N(t) = N_0e^{rt}
$$

What do these equations---and N and r---have to do with each other *mathematically?* We saw graphically that they result in the same curve shapes, which we called "geometric" in the discrete case and "exponential" in the continuous case.

\textcolor{green}{Question:} For what values of $R$ and $r$ respectively do the discrete- and continuous-time models lead to stable population sizes over time?

We can think of $e^r$ and $R$ as being analogous to one another. If we compare the discrete and continuous time equations, we see that they can essentially be substituted for one another. But remember that $r$ is **not the same** as R. To convert instantaneous to time-averaged per capita population change, we need to integrate, which is what $e^r$ does.

In reality, which set of math you use (continuous vs discrete time) depends partly on the system you're studying and partly on mathematical convenience.

### BREAK

### Per capita population change in continuous-time exponential growth

We've been talking about several quantities: Population size $N$ and its change ($dN/dt$), and per capita population growth rate ($R$ or $r$). I want to build your intuition for the relationships between these quantities in the continuous-time exponential model.

Here's a graph of $N$ vs $t$:

```{r}
r = 0.1
n0 = 1000
tvec <- seq(0, 100, 1)
nvec <- n0 + exp(r * tvec)
dat <- data.frame(t = tvec, N = nvec)

ggplot(dat, aes(x=t, y=N)) +
  geom_line() +
  labs(title="Exponential growth in continuous time, r = 0.1") +
  theme_bw()
```

Now, let's plot the derivative of this curve:

```{r}
r = 0.1
N = seq(1000, 25000, 100)
dNdt = r * N

dat <- data.frame(N, dNdt)

ggplot(dat, aes(x=N, y=dNdt)) +
  geom_line() +
  labs(title="Population rate of change vs. population size, r = 0.1") +
  theme_bw()
```

Talk through the intuition behind this graph---that the population-level rate of change is proportional to the population size. (This is true in both continuous and discrete time.) This was obvious mathematically because we knew $dN/dt = rN$, which is the equation for a line of slope $r$, but it isn't always obvious graphically. If we divide both sides of that equation by $N$, we would get a flat line, $r = dN/Ndt$.

# Density-dependent population growth

Hastings pp81-95

## Logistic model

Exponential (or geometric) growth are rare in nature. \textcolor{green}{Discuss: Why?}

The growth of natural populations cannot continue forever. Eventually population growth rates must slow down. \textcolor{green}{Discuss:} Can we think of examples of this in nature? At what population sizes was the population growth rate ($dN/dt$) fast *vs.* slow? Sketch $N$ *vs.* $t$ on the board.

Over and over we see a pattern of fast growth when things are rare (i.e., populations are small) and slowing growth as populations get bigger---think of diseases and invasive species.

\textcolor{green}{Reflect individually:} Many hypotheses have been proposed for what regulates the growth of populations.

-   Changing weather and climate
-   Resources, such as food supply
-   Interactions with other species: predation, parasitism, competition
-   Populations regulate themselves through behavior (territoriality, cannibalism)

The simplest case is one of intrinsic factors (e.g., running out of resources), so we'll start with that one. Earlier we discussed the simplest possible (continuous-time) population model,

$$
\frac{dN}{dt} = rN
$$

Now rather than a constant per-capita growth rate $r$ we introduce a function on the right-hand side,

$$
\frac{dN}{dt} = N \, g(N) 
$$ Now the population growth rate is not simply proportional to population size. $g(N)$ still represents the per-capita growth rate, but *it is no longer a constant.* Because this growth rate is now dependent in some way on $N$, this is called a **density-dependent model.** Exponential growth is a **density-independent model** because $r$ is not dependent on $N$. Recall that in the exponential growth model, we said that if we plotted $N$ *vs.* $dN/Ndt$, we would get a straight line?

```{r}
r = 0.1
N = seq(1000, 25000, 100)
dN_Ndt = r * N / N

dat <- data.frame(N, dN_Ndt)

ggplot(dat, aes(x=N, y=dN_Ndt)) +
  geom_line() +
  labs(title="Per-capita population growth rate vs. population size, r = 0.1") +
  theme_bw()
```

The simplest possible extension to this is that the *per capita population growth rate*, $g(N)$ or $dN/Ndt$, goes down with $N$. This suggests that when the population size is higher, the average number of offspring per individual goes down.

```{r}

# Parameters
r <- 1      # Intrinsic growth rate
K <- 100    # Carrying capacity

# Population values
N_vals <- seq(0, K, by = 1)

# Per capita growth function
g_N <- function(N) {
  r * (1 - N / K)
}

# Create data frame
df <- data.frame(
  N = N_vals,
  g = g_N(N_vals)
)

# Plot
ggplot(df, aes(x = N, y = g)) +
  geom_line(size = 1.2, color = "steelblue") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = K, linetype = "dotted", color = "darkred") +
  annotate("text", x = 0.01 * K, y = 0.99 * r, label = "r", size = 5) +
  annotate("text", x = K - 0.01 * K, y = 0.01 * r, label = "K", size = 5, color = "darkred") +
  
  labs(
    title = "Per Capita Growth Rate in Logistic Model",
    x = "Population Size (N)",
    y = "Per Capita Growth Rate, g(N)"
  ) +
  coord_cartesian() +
  theme_minimal(base_size = 14)

```

The equation describing this line is, $$
g(N) = r(1-\frac{N}{K})
$$

This is the same $r$ as before, but now---as we said previously---the per-capita population growth rate is a function of density as well, and this quantity $K$. $K$ is a core ecological concept called **carrying capacity**. The intuition behind K is that it's the largest population size the ecosystem can sustain without per-capita population growth becoming negative, i.e., deaths outweighing births.

Before we solve the equation above let's try to intuitively reconstruct the relationship between $N$ and $dN/dt$---i.e., to multiply the equation for the line above by *N*. Recall from the exponential model that we are trying to understand three sets of relationships: $dN/Ndt$ *vs.* $N$ (plotted above), $dN/dt$ *vs.* $N$ (which we're about to figure out), and $N$ *vs.* $t$ (which we sketched earlier on the board). \textcolor{green}{Discuss:} Where are the points when population size is not changing? What is $dN/dt$ at those values? What do we think it is between those values?

```{r}
r <- 1      
K <- 100    

N <- seq(0, K, by = 1)

dNdt <- N * r * (1 - N / K)

# Create data frame
df <- data.frame(N, dNdt)

# Plot
ggplot(df, aes(x = N, y = dNdt)) +
  geom_line(size = 1.2, color = "steelblue") +
  #  geom_hline(yintercept = 0, linetype = "dashed") +
  #  geom_vline(xintercept = K, linetype = "dotted", color = "darkred") +
  annotate("text", x = 0.01 * K, y = 0.99 * r, label = "N=0", size = 5) +
  annotate("text", x = K - 0.01 * K, y = 0.01 * r, label = "N=K", size = 5)  
labs(
  title = "Growth Rate in Logistic Model",
  x = "Population Size (N)",
  y = "Growth Rate, dN/dt"
) +
  coord_cartesian() +
  theme_bw()
```

Because $g(N)$ = $dN/Ndt$, if $g(N) = r(1-\frac{N}{K})$, then the equation for the curve above simply multiplies both sides by $N$:

$$
\frac{dN}{dt} = rN(1-\frac{N}{K})
$$

This is the logistic population rate of change in continuous time. We'll pick up next week with stability analyses, integration of the above equation, and discrete-time logistic growth.

# Density-dependent population models, continued

Hastings pp81-95

Let's start by putting on the board what we learned last week:

Geometric growth in discrete time---$N_{t+1}=RN$, from which we calculated that $N=N_0R^t$, and exponential growth in continuous time---$dN/dt=rN$, which we integrated to find that $N(t) = N_0e^{rt}$. \textcolor{green}{What is the per capita growth rate in each of these models?} Answer: in discrete time, it's $R = N_{t+1}/N$, and in continuous time, it's $r=dN/Ndt$. Recall these are both constants! This is basically the only model in which per capita growth is a constant.

We addressed that assumption by making per capita growth conditional on population size, such that $dN/Ndt = r(1-\frac{N}{K})$. If we multiply both sides by N to get the population growth rate, we get $dN/dt = rN(1-N/K)$. This is called the logistic model in continuous time. Integrating this equation leads us to:

$$
N(t) =  \frac{N_0e^{rt}}{1+N_0(e^{rt}-1)/K}
$$ If you want to challenge yourself to walk through this integral, it's on p84-85 of the textbook. Before we go any further, let's draw $N$ vs. $t$, $dN/dt$ vs. $N$, and $dN/Ndt$ vs. $N$ on the board.

## Stability and equilibrium analysis

In this class, our goal is always to connect math to populations. How well does the logistic model describe populations? In some cases, it may describe (and predict!) them quantitatively. But often we don't have the ability to fit this model well, or it fits the data we have but as population dynamics unfold it turns out it wasn't very predictive. \textcolor{green}{What are some ways that we might think a logistic model is fitting well and then learn later we were wrong?}

This model may be most useful in making *qualitative* predictions. These are more robust (meaning that they won't change with changes to the model parameters, unlike quantitative predictions). One great way to do this is through equilibrium analysis.

**Equilibria** are points where the population is *stable*. Mathematically, what does that mean in terms of the quantities we have been calculating and plotting?

If we want to know at what size the population is stable, i.e. $dN/dt = 0$, for any model, we can just set the equation for $dN/dt$ equal to zero, and figure out at what population sizes (N) it solves to 0. Let's try that for the exponential model first:

$$
\frac{dN}{dt} = rN = 0
$$ This model only has one equilibrium state, when $N = 0$. \textcolor{green}{Does it make sense that an exponential-growth model has no stable population size once N > 0?}

Let's do the logistic model next:

$$
\frac{dN}{dt} = rN(1-\frac{N}{K}) = 0
$$

This equation has two solutions, $\hat{N}=K$ and $\hat{N}=0$. (It's always worth checking if $N=0$ is a solution; it usually is, because extinct populations are stable!)

In addition to finding this algebraically, we could have figured it out graphically. \textcolor{green}{How?} By graphing $dN/dt$ vs. $N$ and looking for the population sizes at which growth rates are zero.

We're going through this whole exercise to build more intuition about the qualitative predictions of these models. Last week we talked about how the logistic model, qualitatively, predicts rapid *per capita* growth when populations are small, and a leveling-off when populations are big. Equilibrium analysis gives us a different kind of intuition: it helps us understand when populations *are likely to remain where they are.*

Equilibrium analysis has a mathematical meaning: it's when the derivative goes to zero, meaning the system is not changing. But this can happen for a blink of an eye or for a long time. Whether we reach a **stable equilibrium** affects the qualitative behavior we expect. \textcolor{green}{Intuitively, what do you think is the difference between a stable and an unstable equilibrium?}

To find out whether equilibria or stable or unstable, we need to understand the behavior of solutions near the equilibrium point. The most intuitive way to do this is graphically. Returning to our graph:

```{r}
r <- 1      
K <- 100    

N <- seq(0, K + 10, by = 1)

dNdt <- N * r * (1 - N / K)

# Create data frame
df <- data.frame(N, dNdt)

# Plot
ggplot(df, aes(x = N, y = dNdt)) +
  geom_line(size = 1.2, color = "steelblue") +
  annotate("text", x = 0.01 * K, y = 0.99 * r, label = "N=0", size = 5) +
  annotate("text", x = K - 0.01 * K, y = 0.01 * r, label = "N=K", size = 5)  
labs(
  title = "Growth Rate in Logistic Model",
  x = "Population Size (N)",
  y = "Growth Rate, dN/dt"
) +
  coord_cartesian() +
  theme_bw()
```

If the population is close to $\hat{N}=0$, what happens to $dN/dt$? Does that bring it closer to or further from the equilibrium? \[Draw arrows showing that as N increases, $dN/dt$ increases, so small perturbations will drive the system away from that equilibrium, meaning it is unstable.\]

If the population is close to $\hat{N}=K$, what happens to $dN/dt$? Does that bring it closer to or further from the equilibrium? \[Draw arrows showing that as N increases, $dN/dt$ decreases, and as N decreases, $dN/dt$ increases, so small perturbations will drive the system toward that equilibrium, meaning it is stable.\]

This conclusion---that the equilibrium $\hat{N}=0$ is an unstable one, and that $\hat{N}=K$ is a stable equilibrium, is a feature of many models with density-dependence---not just the logistic function. This happens whenever we have the qualitative pattern that *per capita* growth is high when populations are rare, and when we have feedbacks to slow population growth when populations are abundant (i.e., "negative" density dependence.)

### Local stability analysis: the graphical explanation

Above we mathematically found equilibria by setting the derivative function $dN/dt = 0$ and solving it. But that didn't tell us whether the equilibrium was stable or unstable. We can also do that mathematically, but it takes a bit more work. To find an equilibrium we have to set the function, say $G(N)$, equal to 0. To find if the equilibrium is stable, we have to understand the *slope* of the function near that equilibrium---specifically, whether the slope is negative (stable) or positive (unstable). Keep in mind that these are slope values *at an intercept*, because we're already at an equilibrium, which means by definition that $G(N) = 0$. The reason that a negative-slope function crossing the intercept creates a stable equilibrium is that, if $N$ goes down a little (below $\hat{N}$), suddenly the function is positive and brings the population back up. Conversely, if $N$ goes up a little, suddenly the function is negative and brings $N$ back down. The inverse is true for a positive-slope function crossing the intercept (and creating an unstable equilibrium).

### Local stability analysis: the mathematical explanation (optional)

The more mathematical way to do this is to actually calculate the slope of the derivative function $G'(N)$ and ask whether it is negative or positive at different equilibria. We can do this for any population model in two steps (finding the equibria and then testing them for stability). We're going to walk through this in great detail here becuase you can build a lot of intuition about stability from the logistic model, which is relatively straightforward. In future models you may not do all the math but this will help you understand the relationship between the population model and the stability of its equilibria.

We begin, again, by setting the derivative equal to 0---for convenience we're going to call it $G(N)$ and say that the values of $N$ that give equilibria (i.e., $G(N) = 0$) are $\hat{N}$. So, we're looking for:

$$
G(\hat{N}) = 0
$$

We already identified the equilibria for the logistic model earlier ($\hat{N}=0$ and $\hat{N}=K$). Next, we want to understand the dynamics of $G(N)$ when it is close to $\hat{N}$. We use a similar approach as we do for derivation: we think about the value of $G(N)$ very close but not exactly at $\hat{N}$, and try to understand its behavior as we approach $\hat{N}$. Let's define a new quantity $n$, defined as the *deviation from the equilibrium in units of N*: $n + \hat{N} = N$.

We want to understand how $n$ changes with time. That sounds like a derivative! Let's differentiate both sides of that equation, $n + \hat{N} = N$. Since $\hat{N}$ is a constant, the left- and right-hand sides of the equation above have the same derivative:

$$
dn/dt = dN/dt
$$

And recall that since we defined $G(N) = dN/dt$ and $x + \hat{N} = N$,

$$
dn/dt = G(N) = G(n + \hat{N})
$$

We really just want to understand the dynamics of $G(N)$ when $N = x + \hat{N}$. We can approximate the value of the population size equation, $G(N)$, at this value using a *Taylor series.* A Taylor series allows us to approximate any function at a single point. As Hastings (p55) says, "any function $f(x)$ can be approximated near the value $x_0$ using a *Taylor series* as $f(x_0)$ plus the difference between $x$ and $x_0$ multiplied by how much the function $f$ changes as its argument, $x$, changes:"

$$
f(x) \approx f(x_0) + (x-x_0) \frac{df}{dx} \Big|_{x=x_0}
$$

In our applications, $f(x_0)$ is always an equilibrium point that corresponds to a known value of $N$. Let's try to re-write the equation for the Taylor series above in our use case.

$$
G(\hat{N} + n) \approx G(\hat{N}) + n \frac{dG}{dN} \Big|_{N=\hat{N}}
$$

In words, this equation is telling us that the rate of population growth a little bit away from the equilibrium value can be approximated by the rate of population growth at the equilibrium value plus an extra term, calculated by multiplying the distance from equilibrium by how fast the function is changing when it is close to the equilibrium value.

Let's substitute in the actual equation for the rate of population change in the logistic model:

$$
G(N) = rN(1-\frac{N}{K})
$$

Let's deal with the easiest part of our Taylor series first. We know that at $\hat{N}$, the population is at equilibrium, so $dN/dt = G(N) = 0$. (You can also convince yourself of that by substituting 0 into the logistic growth equation above.) This simplifies our Taylor series down to:

$$
G(\hat{N} + n) \approx n \frac{dG}{dN} \Big|_{N=\hat{N}}
$$

Next we'll figure out that weird term on the right. What is $dG/dN$? Well, that sounds a lot like the derivative of a function called $G(N)$ with respect to $N$. No problem! We can find the derivative of that function, $rN(1-N/K)$. Let's rearrange it to look more like a polynomial:

$$
G(N) = rN - \frac{rN^2}{K}
$$

Now we can totally take the derivative of this. The derivative of $rN$ with respect to $N$ is just $r$, since $r$ is a constant. To calculate the second term, let's separate out $N^2$: $d/dN (N^2 \times R/K)$. The derivative of $N^2$ is just $2N$, so that term becomes $2rN/K$.

$$
G'(N) = dG/dN = r - \frac{2rN}{K}
$$

Now, we're ready to calculate the Taylor approximation at both equilibria. Let's substitute the equation we just derived for $dG/dN$:

$$
G(\hat{N} + n) \approx n \frac{dG}{dN} \Big|_{N=\hat{N}} \approx n \big(r - \frac{2rN}{K} \Big|_{N=\hat{N}} \big)
$$

Let's start with $\hat{N} = 0$. In this case, we get:

$$
G(\hat{N} + n) \approx rn
$$

This is positive, implying it is an **unstable equilibrium.** Next, we want $\hat{N} = K$:

$$
G(\hat{N} + n) \approx n \big(r - \frac{2rK}{K} \big) = n(r - 2r) = n(-r) = -rn
$$

This is negative, implying it is a **stable equilibrium.**

### Local stability analysis: the mathematical shortcut

You can generalize this procedure of mathematical stability analysis by simply saying that we want to calculate the slope of $G'(N)$ at a small deviation from equilibrium, $n = N - \hat{N}$. We can approximate $dN/dt \approx \lambda n$, where

$$
\lambda = \frac{dG}{dN} \Big|_{N = \hat{N}}
$$

If $\lambda$ is positive the equilibrium is unstable, and it's stable if negative. In other words, all you need to do is get the equation for the derivative of the population growth function and evaluate it at $\hat{N}$. (Hastings, 91: "The rate of return to the equilibrium, or the rate at which the system moves away from the equilibrium, is determined by $\lambda$.") The reason this works is the Taylor expansion we walked through, but in practice you'd mostly use the equation above---or the graphical interpretation---to evaluate stability.

Here's how that would have looked for the logistic model:

$$
G(N) = dN/dt = rN(1-N/K)
$$

Restating the equation as $rN - rN^2/K$ and taking the derivative:

$$
G'(N) = dG/dN = r - \frac{2rN}{K}
$$

Plugging in 0 for $N$ gives you $G'(N) = r$, and plugging in $K$ gives you $G'(N) = -r$.

# Extensions to harvested populations

One of the remarkable things about population modeling is that it really underpins a lot of how we manage ocean resources---from marine spatial planning (we'll get to that in the metapopulations lecture) to fisheries management.

\textcolor{green}{Discuss:} What would sustainable fisheries mean in quantitative terms? What do we want the terms we've learned about so far to be or not be? Are we trying to maximize or minimize something? If so, what quantity?

## Maximum sustainable yield in a logistic model (constant harvest)

Let's assume we have a fish population that actually follows the logistic growth model. If we imagine subtracting a set quota of fish every year, $H$, then

$$
\frac{dN}{dt} = rN(1 - N/K) - H
$$

\textcolor{green}{How would harvest affect our graph of $dN/dt$ vs. $N$?}

Start out by drawing the curve with no $H$ and then a moderate $H$. Discuss the equilibrium points and whether they are stable or unstable. Then add the line for $H=H_{max}$. May want to draw this with H bringing up the x-axis rather than bringing the curve down.

```{r}
library(ggplot2)
library(dplyr)

# Parameters
r <- 1
K <- 100
H_max <- r * K / 4  # maximum sustainable harvest

# Harvest values and labels
H_vals <- c(0, H_max / 2, H_max)
harvest_labels <- data.frame(
  H = H_vals,
  H_label = paste0("H = ", round(H_vals, 2))
)

# Population values
N_vals <- seq(0, 120, by = 0.5)

# Define the logistic growth with harvesting
F_N <- function(N, H) {
  r * N * (1 - N / K) - H
}

# Create data frame
df <- expand.grid(N = N_vals, H = H_vals) %>%
  mutate(dNdt = F_N(N, H)) %>%
  left_join(harvest_labels, by = "H")

# Plot
ggplot(df, aes(x = N, y = dNdt, color = H_label)) +
  geom_line(size = 1.2) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(
    title = "Logistic Growth With Varying Harvest Rates",
    subtitle = paste("H_max =", round(H_max, 2), "occurs at N = K/2 =", K / 2),
    x = "Population Size (N)",
    y = "dN/dt",
    color = "Harvest Rate"
  ) +
  theme_minimal(base_size = 14)

```

Is the equilibrium at $H=H_{max}$ stable or unstable? Let's use our rule of thumb previously to figure this out.

$$
G'(N) = dG/dN = r - \frac{2rN}{K}
$$

Because $H_{max} = K/2$, we can state:

$$
r - \frac{2rN}{K} = r - \frac{2r \times K/2}{K} = r - r = 0
$$

Zero! We didn't have a rule of thumb for this above. We know that at this point, the first derivative of population size $dN/dt$ or $F'(N)$ is zero (because we're at the x-intercept), and the second derivative $dG/dN$ or $G'(N)$ or $F''(N)$ is... also zero---meaning the slope is flat. In math this is called a "degenerate case" because the system is neither classically stable or unstable. But we can figure out the answer graphically. Let's call $H_{max} = 25$ fish/year and $K = 100$. Then at $H_{max}$, $N = 50$. What happens if we slightly overshoot---meaning we harvest 26 fish by accident? Then $dN/dt$ becomes negative---in other words, the population's natural rate of increase is less than $H_{max}$. What happens if we harvest 24 fish? That essentially shifts the curve upwards by 1---so you are back in the land of two equilibria, a stable one at higher $N$ and an unstable one at lower $N$. This is a *saddle-node bifurcation*: it is stable on one side, and unstable on the other. (We can also see this graphically at the top of the parabola.)

This point is *an optimal harvest level from an economic standpoint* because it maximizes revenue by balancing production (of the fish stock) with returns (of harvest). There is no mathematical solution that yields greater yearly harvest. However, **it is not stable**, and is extremely sensitive to any level of overharvesting. Roughgarden and Smith (1996) wrote, "Maintaining the stock at the optimal size... is like balancing a marble on top of a dome." \textcolor{green}{What are some other reasons why this might not be the most realistic or wise approach to fisheries management?}

To emphasize this point, here are some plots of N vs. t in a logistic-growth, constant-harvest scenario with different levels of H. Let's start by assuming we are already at K/2 (i.e., $N_0=K/2$):

```{r}
library(deSolve)
library(ggplot2)
library(dplyr)

# Parameters
r <- 1
K <- 100
H_max <- r * K / 4
N0 <- 50
times <- seq(0, 8, by = 0.1)

# Define harvest levels (values first, labels after)
H_values <- c(0, 5, 20, H_max, 30)
H_labels <- c("No harvest",
              "Low (H = 5)",
              "High (H = 20)",
              paste0("Hmax (H = ", H_max, ")"),
              "Overharvest (H = 30)")
names(H_values) <- H_labels

# Logistic model with constant harvest
logistic_harvest <- function(t, state, parms) {
  with(as.list(c(state, parms)), {
    dN <- r * N * (1 - N / K) - H
    if (N <= 0) dN <- 0
    return(list(c(dN)))
  })
}

# Solve for each H
results <- lapply(names(H_values), function(label) {
  H <- H_values[[label]]
  out <- ode(y = c(N = N0), times = times,
             func = logistic_harvest,
             parms = c(r = r, K = K, H = H))
  df <- as.data.frame(out)
  df$Harvest <- label
  return(df)
})

df_all <- bind_rows(results)

# Plot
ggplot(df_all, aes(x = time, y = N, color = Harvest)) +
  geom_line(size = 1.2) +
  labs(
    title = "Logistic Growth with Constant Harvest",
    subtitle = paste("r =", r, ", K =", K, ", N0 =", N0),
    x = "Time (t)",
    y = "Population Size (N)"
  ) +
  theme_minimal(base_size = 14) +
  scale_color_brewer(palette = "Set1")

```

What if we draw the same curves with $N_0=0$?

```{r}
library(deSolve)
library(ggplot2)
library(dplyr)

# Parameters
r <- 1
K <- 100
H_max <- r * K / 4
N0 <- 10
times <- seq(0, 8, by = 0.1)

# Define harvest levels (values first, labels after)
H_values <- c(0, 5, 20, H_max, 30)
H_labels <- c("No harvest",
              "Low (H = 5)",
              "High (H = 20)",
              paste0("Hmax (H = ", H_max, ")"),
              "Overharvest (H = 30)")
names(H_values) <- H_labels

# Logistic model with constant harvest
logistic_harvest <- function(t, state, parms) {
  with(as.list(c(state, parms)), {
    dN <- r * N * (1 - N / K) - H
    if (N <= 0) dN <- 0
    return(list(c(dN)))
  })
}

# Solve for each H
results <- lapply(names(H_values), function(label) {
  H <- H_values[[label]]
  out <- ode(y = c(N = N0), times = times,
             func = logistic_harvest,
             parms = c(r = r, K = K, H = H))
  df <- as.data.frame(out)
  df$Harvest <- label
  return(df)
})

df_all <- bind_rows(results)

# Plot
ggplot(df_all, aes(x = time, y = N, color = Harvest)) +
  geom_line(size = 1.2) +
  labs(
    title = "Logistic Growth with Constant Harvest",
    subtitle = paste("r =", r, ", K =", K, ", N0 =", N0),
    x = "Time (t)",
    y = "Population Size (N)"
  ) +
  theme_minimal(base_size = 14) +
  scale_color_brewer(palette = "Set1")
```

## Alternatives to MSY management (constant effort)

Are there more robust ways to achieve sustainable yields than setting harvest quotas equal to the maximum $dN/dt$? An alternative to a constant harvest rate (measured in fish per unit time) is a constant effort model (still measured in units of fish per time, but now a dynamic equation). Here, harvest is proportional to population size and **effort** (the intensity of fishing, e.g., hours on the water, number of nets deployed, etc.)

Instead of

$$
\frac{dN}{dt} = rN(1 - N/K) - H
$$

Where $H$ was a constant rate, we now have:

$$
\frac{dN}{dt} = rN(1 - N/K) - qEN
$$

Where N is the population size, q is a catchability coefficient (more on this later), and E is effort. Wait---but shouldn't this still be a rate? Let's work through the units and intuition of these different parameters.

The unit of N is individuals. The unit of E is effort; something like boats, days, permits, traps, etc. \textcolor{green}{For this to end up in the same units of individuals per time, what are the units of $q$?}

q is measured in 1 / (effort x individuals x time). Here, it's a scaling constant that translates the fishing effort into the number of fish that will actually be caught.

So q is a constant here. Since this is a "constant effort" model, E is also a constant! It tells us that regardless of how many fish are in the ocean, the fishing industry will do the same thing to try to catch them. \textcolor{green}{Is this a more or less realistic model than the constant harvest model, above?}

But because N is not a constant, harvest here ($qEN$) is now a dynamic equation. \textcolor{green}{What form would you expect this equation to take?}

Let's draw it on top of our now-familiar curve for $dN/dt$ vs. $N$ in the logistic model. \textcolor{green}{For moderate levels of E, where are the equilibria? Which are stable and which are not?}

```{r}
library(ggplot2)
library(dplyr)

# Parameters
r <- 1          # Intrinsic growth rate
K <- 100        # Carrying capacity
q <- 0.01       # Catchability
E_vals <- c(10, 20, 40, 80)  # Different effort levels
N_vals <- seq(0, 120, by = 1)

# Logistic growth function
logistic_growth <- function(N) {
  r * N * (1 - N / K)
}

# Create growth data
growth_df <- data.frame(
  N = N_vals,
  dNdt = logistic_growth(N_vals)
)

# Create harvest data
harvest_df <- expand.grid(N = N_vals, E = E_vals) %>%
  mutate(H = q * E * N,
         E_label = factor(E, labels = paste("Effort E =", E_vals)))

# Plot
ggplot() +
  # Harvest curves
  geom_line(data = harvest_df, aes(x = N, y = H, color = E_label), size = 1.2) +
  # Logistic growth curve
  geom_line(data = growth_df, aes(x = N, y = dNdt), color = "black", size = 1.2) +
  labs(
    title = "Logistic Growth and Constant Effort Harvest",
    subtitle = "Black curve: dN/dt = rN(1 - N/K), Colored lines: H = qEN",
    x = "Population Size (N)",
    y = "Rate (individuals per unit time)",
    color = "Fishing Effort"
  ) +
  theme_minimal(base_size = 14)

```

For moderate levels of effort, aside from the trivial equilibrium of $N=0$ (no fish = no growth), there is only one other equilibrium, and it is stable. If population size exceeds harvest, then the population will grow up to the point where the diagonal crosses the curved line. If harvest exceeds population growth (i.e., if you go further up the constant effort line), then population size will go down, and effort will also go down. Let's explore this mathematically by writing the equation for this model and setting it equal to 0.

$$
0 = rN(1 - N/K) - qEN = rN - rN\^2/K - qEN = N(r - rN/K - qE) = N(r(1-N/K)-qE)
$$

What are the solutions to this equilibrium? As we said above there is one where $N=0$. To find the other, we start with

$$
qE = r(1-N/K)
$$

and solve for N:

$$
qE/r = 1-N/K
$$

$$
N/K = 1 - qE/r
$$

$$
\hat{N} = K(1-qE/r)
$$

**When does this yield a stable equilibrium?** Well, let's take the derivative of ($dN/dt$) and plug in our equilibrium value, $\hat{N}$.

$$
G(N) = rN(1 - N/K) - qEN = N(r-qE) -N^2(r/K)
$$

$$
G'(N) = r-qE-2N(r/K)
$$

Plugging in $\hat{N}$,

$$
G'(\hat{N}) = r-qE-2(K(1-\frac{qE}{r}))(\frac{r}{K}) = r - qE - 2r(1-\frac{qE}{r}) = r - qE - 2r + 2qE = qE - r
$$

Great! But now ... is $qE-r$ positive or negative? \textcolor{green}{What is the intuition behind the difference between these two numbers?} Recall that $r$ is the intrinsic growth rate or the maximum per capita growth rate, which $dN/Ndt$ approaches when N is small. $qE$ is in the same units and represents the harvest rate per capita.

\textcolor{green}{So, under what circumstances is this a stable equilibrium?} It's when $qE < r$, meaning that the per capita harvest rate never exceeds the population's intrinsic growth rate.

Let's go back to our graph of constant effort and draw a really high effort rate. \textcolor{green}{Does this ever have a stable equilibrium?} You can see that it does not graphically, because it never intersects the growth function when it has a negative slope (meaning that $G'(\hat{N})$ would be negative).

So you know, this "constant effort" model has a name in fisheries: the Schaefer model. As Marc Mangel wrote in the Theoretical Ecologist's Toolbox (p215), "The Schaefer model involves a single variable $N(t)$ denoting the biomass of the stock, logistic growth of that biomass in the absence of harvest, and harvest proportional to abundance." So---just like the MSY concept in logistic growth---this model is actually being used in natural resource management. 

\textcolor{green}{Discuss:} What else might cause overfishing or collapse of a harvested population that isn't captured here?

## Other forms of density dependence in continuous time

We've been working a lot with plots of $dN/dt$ vs. $N$. But recall that we usually think about three plots: $N$ vs. $t$, $dN/dt$ vs. $N$, and $dN/Ndt$ vs. $N$. We're going to revisit the latter. Recall that this was a straight, horizontal line in the exponential, continuous-time model, and it was a straight, sloping line in the logistic, continuous-time model. This represents an assumption that density dependence is linear: i.e., that as N increases, the density-dependent term (1-N/K) decreases linearly from 1 (at N=0) to 0 (at N=K). This implies that per capita growth slows down at a constant rate as populations increase.

### Gompertz model

This is an easy thing to modify, because in reality, we might expect this relationship to be nonlinear: maybe per capita growth is not super sensitive at low N, and then drops steeply at high N. Let's try this equation instead:

$$
dN/Ndt = r \ ln (K/N)
$$

(Because $ln(A/B) = -ln(B/A)$, you could also restate this as $-r \ ln(N/K)$, if you want to compare it more directly to the slope we had before with $K$ in the denominator.)

```{r}
library(ggplot2)

# Parameters
r_L <- 1.5       # logistic r
K_L <- 100     # logistic K

r_G <- 0.5     # gompertz r (lower to cross)
K_G <- 80     # gompertz K (higher to cross)

N_vals <- seq(1, 110, by = 1)

# Per capita growth functions
logistic_percap <- r_L * (1 - N_vals / K_L)
gompertz_percap <- r_G * log(K_G / N_vals)

df_percap <- data.frame(
  N = N_vals,
  Logistic = logistic_percap,
  Gompertz = gompertz_percap
)

ggplot(df_percap, aes(x = N)) +
  geom_line(aes(y = Logistic, color = "Logistic"), size = 1.2) +
  geom_line(aes(y = Gompertz, color = "Gompertz"), size = 1.2) +
  labs(
    title = "Per Capita Growth Rate vs. Population Size",
    subtitle = "Adjusted parameters so curves intersect",
    y = "Per Capita Growth Rate (1/N × dN/dt)",
    x = "Population Size (N)",
    color = "Model"
  ) +
  theme_minimal(base_size = 14)

```

We said earlier that the Gompertz model was going to start off with gradual population growth and then show steeper density dependence at high $N$. Let's plot $dN/dt$ vs. $N$ to explore this.

```{r}
# Net growth rate functions
logistic_growth <- r_L * N_vals * (1 - N_vals / K_L)
gompertz_growth <- r_G * N_vals * log(K_G / N_vals)

df_growth <- data.frame(
  N = N_vals,
  Logistic = logistic_growth,
  Gompertz = gompertz_growth
)

ggplot(df_growth, aes(x = N)) +
  geom_line(aes(y = Logistic, color = "Logistic"), size = 1.2) +
  geom_line(aes(y = Gompertz, color = "Gompertz"), size = 1.2) +
  labs(
    title = "Net Growth Rate vs. Population Size",
    subtitle = "Same parameters as per capita growth comparison",
    y = "Net Growth Rate (dN/dt)",
    x = "Population Size (N)",
    color = "Model"
  ) +
  theme_minimal(base_size = 14)

```

And finally, $N$ vs. $t$.

```{r}
# Time and initial population
t_vals <- seq(0, 20, by = 0.1)
N0 <- 10

# Logistic solution
logistic_Nt <- K_L / (1 + ((K_L - N0)/N0) * exp(-r_L * t_vals))

# Gompertz solution
gompertz_Nt <- K_G * exp(log(N0 / K_G) * exp(-r_G * t_vals))

df_time <- data.frame(
  t = t_vals,
  Logistic = logistic_Nt,
  Gompertz = gompertz_Nt
)

ggplot(df_time, aes(x = t)) +
  geom_line(aes(y = Logistic, color = "Logistic"), size = 1.2) +
  geom_line(aes(y = Gompertz, color = "Gompertz"), size = 1.2) +
  labs(
    title = "Population Growth Over Time",
    subtitle = "Same parameters as growth rate plots",
    x = "Time (t)",
    y = "Population Size (N)",
    color = "Model"
  ) +
  theme_minimal(base_size = 14)


```

Note that the shape of these curves relative to one another is totally dependent on the parameter values. One $K$ may be higher than the other, depending on parameters. The thing to remember about the Gompertz model is basically just that the relationship between per capita growth rate and population size is nonlinear, which may fit some data and some models better. If you work in fisheries and you hear someone mention a Gompertz model, just understand it is a density-dependent, continuous-time model that has a slightly different formulation than the logistic.

## Positive density dependence

All of the density dependence we've been talking about so far is technically called *negative density dependence.* It's confusing to remember which is which, but think of it this way: is the relationship between population size and average offspring (per-capita population growth rate, $dN/Ndt$) positive or negative in the logistic model?

There's another way that density can interact with per-capita population growth rate. Think about abalone in California. All seven of our abalone species are endangered (six are critically endangered). These were massively depleted by humans because they are really easy to access and harvest. Disease, warming, heatwaves, and kelp loss have also negatively impacted these species.

Abalone are broadcast spawners. They have separate sexes, so the eggs and sperm need to meet in the water. If there are too few of them, this won't happen and we'll see a *recruitment failure*---when reproduction fails to lead to a new generation of an ecologically meaningful size.

\textcolor{green}{How would this affect the plot of N vs. dN/Ndt in the logistic growth model?}

We can model this effect by introducing a new parameter into the *continuous-time* logistic growth equation, $A$ (this stands for **Allee effect,** another word for this form of positive density dependence.) Then the population growth rate is given by

$$
dN/dt = rN(N-A)(1-N/K)
$$

Let's start by finding the equilibria of this model. Because it's a product of three terms, we can say from looking at it that it will be equal to zero if any one of the three terms is zero. The first equilibrium is when $rN = 0$; because r is a constant, that means $\hat{N}=0$. The second is when $N-a=0$, so we also have $\hat{N}=A$. Finally, if $(1-N/K)=0$, we get $\hat{N}=K$.

To figure out if these equilibria are stable, let's graph the equation above.

```{r}
library(ggplot2)

# Parameters
r <- 1
K <- 100
A <- 30

# Allee effect model function
allee_growth <- function(N) {
  r * N * (N-A) * (1 - N/K)
}

# Generate values of N
N_vals <- seq(0, 120, by = 0.1)
dNdt_vals <- allee_growth(N_vals)

# Create data frame
df <- data.frame(N = N_vals, dNdt = dNdt_vals)

# Plot
ggplot(df, aes(x = N, y = dNdt)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(size = 1.2, color = "steelblue") +
  geom_vline(xintercept = c(0, A, K), linetype = "dotted", color = "gray40") +
  annotate("text", x = 0, y = 5, label = "N = 0", hjust = -0.1) +
  annotate("text", x = A, y = 5, label = "N = A", hjust = -0.1) +
  annotate("text", x = K, y = 5, label = "N = K", hjust = -0.1) +
  labs(
    title = expression("Growth Rate with Allee Effect:" ~ frac(dN, dt) == r*N*~(N-A)*(1 - frac(N, K))),
    x = "Population Size (N)",
    y = expression(dN/dt)
  ) +
  theme_minimal(base_size = 14)

```

\textcolor{green}{Graphically, which equilibria are stable and which are unstable?}

\textcolor{green}{Take a couple minutes to think and draw: What do you think the graph of N vs t will look like for a few different values of $N_0$?}

```{r}
library(deSolve)
library(ggplot2)
library(dplyr)

# Parameters
r <- 1
K <- 100
A <- 30

# Allee model ODE
allee_model <- function(t, state, parms) {
  N <- state["N"]
  dN <- r * N * (N/A - 1) * (1 - N/K)
  return(list(c(dN)))
}

# Initial conditions
N0_vals <- c(10, 25, 30, 40, 100)  # below, at, and above A
times <- seq(0, 50, by = 0.1)

# Run simulations for each initial value
trajectories <- lapply(N0_vals, function(N0) {
  out <- ode(
    y = c(N = N0),
    times = times,
    func = allee_model,
    parms = NULL
  )
  as.data.frame(out) %>%
    mutate(N0 = paste0("N0 = ", N0))
})

df_all <- bind_rows(trajectories)

# Plot
ggplot(df_all, aes(x = time, y = N, color = N0)) +
  geom_line(size = 1.2) +
  labs(
    title = "Population Trajectories under Allee Effect",
    subtitle = "Different initial population sizes relative to Allee threshold A",
    x = "Time (t)",
    y = "Population Size (N)",
    color = expression(N[0])
  ) +
  theme_minimal(base_size = 14)

```

# Time lags and density dependence

One criticism that would be very valid of all the models we have discussed so far is that they are too "neat." You all plotted data of an actual system this week, and saw that it is almost certainly much more dynamic than these smooth curves. The textbook goes into more detail about criticism of the logistic model, which mostly centers around it being very difficult to quantitatively prove, partly because it's hard to know if a stable equilibrium has been reached when looking at real data, and partly because our ability to estimate the exact parameters (of any density-dependent model---logistic, Gompertz, etc.) is limited.

## Delayed logistic

(Hastings pp 92-96) Most of the rest of the course will be adding different forms of complexity to better approximate real systems. Probably the next simplest case is a population that does not reach a single stable equilibrium, but instead oscillates around $K$. This is common in microbes and insects, especially in laboratory studies.

The analogy in the textbook is a thermostat in a room: even though the mean air temperature is at a given setting, in practice the continuous temperature probably repeatedly dips and warms. We can model this relatively simply by introducing a time delay in the logistic model. This implies that there is a lag between when population size changes, and when population growth rate changes. We call that lag $T$, and define

$$
dN/dt = rN_t(1-N_{t-T}/K)
$$

You can see here that the effect of density dependence (1-N/K) is lagged $T$ amount behind $t$.

```{r}
library(deSolve)
library(ggplot2)

# Parameters
r <- .5        # intrinsic growth rate
K <- 100      # carrying capacity
T_delay <- 4  # time delay
N0 <- 3      # initial population

# Define the delayed logistic model
delayed_logistic <- function(t, state, parms) {
  with(as.list(c(state, parms)), {
    # Check if the lag value is defined
    if (t <= T_delay) {
      N_lag <- N0  # before delay kicks in
    } else {
      N_lag <- lagvalue(t - T_delay)
    }
    dN <- r * N * (1 - N_lag / K)
    return(list(dN))
  })
}

# Parameters and initial state
parms <- c(r = r, K = K)
state <- c(N = N0)
times <- seq(0, 50, by = 0.1)

# Solve the delayed differential equation
out <- dede(y = state, times = times, func = delayed_logistic, parms = parms)

# Plot the result
out_df <- as.data.frame(out)

ggplot(out_df, aes(x = time, y = N)) +
  geom_line(size = 1.2, color = "steelblue") +
  labs(
    title = "Delayed Logistic Population Growth",
    subtitle = paste("Delay T =", T_delay, ", r =", r),
    x = "Time",
    y = "Population Size (N)"
  ) +
  theme_minimal(base_size = 14)

```

This is a really fun equation to play around with, because you can see that the predicted dynamics change with r and T (and, specifically, their product; you get oscillations when $rT > \pi /2 \approx 1.57$, and sustained oscillations at even greater values.) If I shrink T I get damped oscillations:

```{r}
library(deSolve)
library(ggplot2)

# Parameters
r <- .5        # intrinsic growth rate
K <- 100      # carrying capacity
T_delay <- 2  # time delay
N0 <- 3      # initial population

# Define the delayed logistic model
delayed_logistic <- function(t, state, parms) {
  with(as.list(c(state, parms)), {
    # Check if the lag value is defined
    if (t <= T_delay) {
      N_lag <- N0  # before delay kicks in
    } else {
      N_lag <- lagvalue(t - T_delay)
    }
    dN <- r * N * (1 - N_lag / K)
    return(list(dN))
  })
}

# Parameters and initial state
parms <- c(r = r, K = K)
state <- c(N = N0)
times <- seq(0, 50, by = 0.1)

# Solve the delayed differential equation
out <- dede(y = state, times = times, func = delayed_logistic, parms = parms)

# Plot the result
out_df <- as.data.frame(out)

ggplot(out_df, aes(x = time, y = N)) +
  geom_line(size = 1.2, color = "steelblue") +
  labs(
    title = "Delayed Logistic Population Growth",
    subtitle = paste("Delay T =", T_delay, ", r =", r),
    x = "Time",
    y = "Population Size (N)"
  ) +
  theme_minimal(base_size = 14)

```

And if $rT$ is large I get outcomes that are highly sensitive to initial conditions---even though we haven't introduced any randomness or stochasticity! All we've done is slightly change initial conditions or parameter values, and run a deterministic simple model, but one with time lags.

```{r}
# Parameters
r <- 4
K <- 100
T_delay <- 2.5
dt <- 0.05
t_max <- 100
times <- seq(0, t_max, by = dt)
n_steps <- length(times)

# Convert delay to steps
delay_steps <- round(T_delay / dt)

# Initial values (slightly different to show chaos)
initial_values <- list(
  c(N = 10),
  c(N = 10.01),
  c(N = 10.02)
)

# Run simulations
simulations <- lapply(initial_values, function(init) {
  N <- numeric(n_steps)
  N[1:delay_steps] <- init[["N"]]  # constant initial history
  
  for (t in (delay_steps + 1):n_steps) {
    N_lag <- N[t - delay_steps]
    N[t] <- N[t - 1] + dt * r * N[t - 1] * (1 - N_lag / K)
  }
  
  data.frame(time = times, N = N)
})

# Plot using base R
plot(NULL, xlim = c(0, 10), ylim = c(0, 200),
     xlab = "Time", ylab = "Population Size N(t)",
     main = paste("Chaos in Delayed Logistic Model (r =", r, ", T =", T_delay, ")"))

cols <- c("red", "blue", "darkgreen")
for (i in seq_along(simulations)) {
  lines(simulations[[i]]$time, simulations[[i]]$N, col = cols[i], lwd = 1.5)
}

legend("topright", legend = paste0("N0 = ", sapply(initial_values, `[[`, "N")),
       col = cols, lty = 1, lwd = 2, bty = "n")

```

\textcolor{green}{Have you ever heard of something where tiny changes in initial conditions lead to wildly different outcomes?} People call this the *butterfly effect:* a butterfly flaps its wings and some time later there's a tornado. Mathematically, this means the system is **chaotic.** Even though the system is deterministic, not stochastic, tiny changes in some variables can lead to huge differences.

The delayed logistic model can approximate some, but not all, population dynamics. \textcolor{green}{What species do you think it would describe well? Which would it describe poorly?}

Crucially, it is missing:

-   The effect of different generations and histories of reproductive success (i.e., age structure)
-   More complex lagged effects
-   The effects of seasonal reproduction

# Density dependence in discrete time

(Hastings 96-101)

Let's return to discrete time and explore the dynamics of some discrete-time models that also include density dependence. The first equation we wrote down in this class was:

$$
N_{t+1} = F(N_t)
$$

And I promised you that we'd spend a lot of the class talking about the forms that F can take. The first form we looked at was the simplest,

$$
F(N_t) = RN_t
$$

$$
N_t = N_0R^t
$$

Where the way you get from population size at time t to population size at time t+1 is just multiplying by a constant, R. Let's write down some options with density dependence. \textcolor{green}{Discuss: Qualitatively, what would a discrete-time model for density dependence look like? What would be on the right-hand side of $F(N_t)$?}

## Ricker model

We're starting with this model because we know all the parameters in the equation, although the equation itself is new to us:

$$
N_{t+1} = N_te^{r(1-\frac{N_t}{K})}
$$

Recall how we discussed above that for a discrete-time model to have density dependence, in this equation, $N_t$ would have to be multiplied by something that isn't a constant (and is, in fact, a function of $N$)? Here we go! And notice how similar this is to the continuous-time logistic model. \textcolor{green}{Why might we exponentiate that term? When you raise e to a power, can it ever be negative?}

Most people start with graphs of $N_{t}$ vs. $N_{t+1}$ but I always like to look at a population trend image so we'll do that first.

```{r}
library(ggplot2)
library(tidyr)
library(dplyr)

# Shared parameters
K <- 100
N0 <- 10
steps <- 50

# Ricker parameters
r_ricker <- 2.2
r_ricker_alt <- 0.5
r_ricker_alt2 <- -1
ricker <- function(N, K, r_ricker) N * exp(r_ricker * (1 - N / K))

# Beverton-Holt parameters
R0 <- 3
beverton <- function(N) (R0 * N) / (1 + (R0 - 1) * N / K)

# Initialize vectors
N_ricker <- numeric(steps + 1)
N_bh <- numeric(steps + 1)
N_ricker_alt<- numeric(steps + 1)
N_ricker_alt2<- numeric(steps + 1)
N_ricker[1] <- N_bh[1] <- N0
N_ricker_alt[1] <- N_bh[1] <- N0
N_ricker_alt2[1] <- N_bh[1] <- N0

# Simulate trajectories
for (t in 1:steps) {
  N_ricker[t + 1] <- ricker(N_ricker[t], K, r_ricker)
  N_ricker_alt[t + 1] <- ricker(N_ricker_alt[t], K, r_ricker_alt)
  N_ricker_alt2[t + 1] <- ricker(N_ricker_alt2[t], K, r_ricker_alt2)
  N_bh[t + 1] <- beverton(N_bh[t])
}

# Combine into data frame for plotting
df <- data.frame(
  time = 0:steps,
  Ricker_high_r = N_ricker,
  Ricker_low_r = N_ricker_alt,
  Ricker_neg_r = N_ricker_alt2
  #  Beverton_Holt = N_bh
) %>%
  pivot_longer(cols = -time, names_to = "Model", values_to = "N")

# Plot
ggplot(df, aes(x = time, y = N, color = Model, group = Model)) +
  geom_line(size = 1.2) +
  labs(
    title = "Ricker Model Population Trajectories",
    #  title = "Population Trajectories: Ricker vs. Beverton-Holt",
    subtitle = paste("Initial N_0 =", N0, ", K =", K),
    x = "Time (t)",
    y = expression(N[t])
  ) +
  #  scale_color_manual(values = c("Ricker" = "steelblue", "Beverton_Holt" = "darkgreen")) +
  theme_minimal(base_size = 14)
```

### First return plots

We've been looking at three classes of graphs, but today we're going to add in a fourth one: $N_t$ vs. $N_{t+1}$. These are called "first return" or "next-generation" plots, and they're really common in discrete-time models. This shows how the population at time $t$ determines the population at $t+1$; in other words, given its current value, where will the population go? To orient ourselves to these figures let's quickly plot one for geometric growth, $N_{t+1}=RN_t$ (or $F(N) = R^tN_0$). \textcolor{green}{Take a few minutes and try to draw this figure yourself.}

\textcolor{green}{What graph did we see much earlier in the class that looks like this one?} This plot is highly analogous to $dN/dt$ vs. $N$ in the exponential growth continuous time case. They both describe how the current population size affects the rate of change, and they both give us the direction and speed of population change.

\textcolor{green}{Take a moment to think: Where are the equilibria of this model? How would you know?} Here, we can find equilibria graphically when the function crosses the "identity" (1:1) line. \textcolor{green}{Does the geometric growth model have any equilibria?}

```{r}
# Geometric model parameters
bigR <- 2
N_vals <- seq(0, 100, by = 1)
N_next <- bigR * N_vals

df_geo <- data.frame(N = N_vals, N_next = N_next)

ggplot(df_geo, aes(x = N, y = N_next)) +
  geom_line(color = "orange", size = 1.2) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray50") +
  labs(
    title = "Geometric Growth: N[t+1] vs N[t]",
    subtitle = paste("R =", bigR),
    x = expression(N[t]),
    y = expression(N[t+1])
  ) +
  theme_minimal(base_size = 14)

```

Keeping in mind all the properties of the $dN/dt$ vs. $N$ plot of the logistic continuous-time model above (the upside-down parabola), let's graph the first-return plot for the Ricker model.

```{r}
library(ggplot2)

r <- 2
K <- 100
N_vals <- seq(0, 200, by = 1)
ricker <- N_vals * exp(r * (1 - N_vals / K))

df <- data.frame(N = N_vals, N_next = ricker)

ggplot(df, aes(x = N, y = N_next)) +
  geom_line(color = "steelblue", size = 1.2) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray50") +
  labs(
    title = "Ricker Model: Next Generation vs. Current Population",
    subtitle = paste("r =", r, ", K =", K),
    x = expression(N[t]),
    y = expression(N[t+1])
  ) +
  theme_minimal(base_size = 14)

```

\textcolor{green}{From the Ricker model formula, what is its growth rate when rare?}

Now let's ask all of our usual questions: does this have any equilibria? What does it mean for population size, per capita growth, etc.?

We solved for equilibria above by setting $dN/dt=0$. Here, we want to set $N_t = N_{t+1} = \hat{N}$.

$$
\hat{N} = \hat{N}e^{r(1-\frac{\hat{N}}{K})}
$$

This has a trivial equilibrium at $\hat{N}=0$. But dividing both sides by $\hat{N}$ and taking the log, we get:

$$
0 = r(1-\hat{N}/K)
$$

This simplifies to $\hat{N}=K$. \textcolor{green}{What other model had equilibria at population sizes of 0 and K?} If I were better at drawing you could see that on the graph above as well. Your next question, now that we have found the equilibrium for the Ricker model, might be: But is it stable? Even though this is a discrete-time model, you can still do this by taking the derivative of this equation:

$$
N_{t+1} = N_te^{r(1-\frac{N_t}{K})}
$$

And asking about its behavior at $\hat{N}$. Let's take the derivative of this equation. We're going to take advantage of the **product rule,** which says that for any u and v, $dG/dN = u'v + uv'$. In other words, when we want the derivative of a product, we take the derivative of each, multiply it by the other, and sum them. Here, $u' = 1$ (the derivative of N with respect to N). v' is:

$$
v' = \frac{d}{dN}e^{r(1-N/K)} 
$$

How do we take this derivative? Hopefully this is triggering some vague memories from calculus. You need to remember two things. First, the *chain rule,* which applies to composite functions---like $f(x) = g(h(x))$. Then, $f'(x) = g'(h(x)) \times h'(x)$. In other words you multiply the derivative of the outer function (keeping the inside intact) by the derivative of the inner function. Let's work through this for an exponential function, $f(x) = e^{g(x)}$.

The second thing you need to remember is that the derivative of e to the something is just ... itself! $d/dx \ e^x = e^x$. So, we can separate this into:

$$
v' = \frac{d}{dN}e^{r(1-N/K)} = e^{r(1-N/K)} \times \frac{d}{dN} r(1-N/K)
$$

Now we just have to take the derivative of $r(1-N/K)$, which we've done before. We multiply it out into $r - rN/K$, and when taking the derivative with respect to N, this turns into $-r/K$. So our whole v' turns into $-r/K \times e^{r(1-N/K)}$. Recall that we started with $G(N) = N_te^{r(1-\frac{N_t}{K})}$ and said that $dG/dN = u'v + uv'$ (the product rule). So putting it all together (recall that here, $u' = 1$), we get:

$$
dG/dN = e^{r(1-N/K)} -r/Ke^{r(1-N/K)} \times N = e^{r(1-N/K)} (1-rN/K)
$$

This is the derivative of the Ricker model in discrete time. Remember, we did all this to understand whether the equilibrium $\hat{ N} = K$ is stable or unstable. Let's substitute that in. $e^{r(1-N/K)}$ turns into 1, and so does $N/K$. So we get that $dG/dN = 1 - r$.

## Stability analysis of discrete-time models

\textcolor{green}{In continuous time, what was our stability criterion with respect to this second derivative at the equilibrium value?} Stability in continuous time is defined by the sign of the derivative near the equilibrium. If it's negative, it's stabilizing, and if it's positive, it's destabilizing. Think back to our plots of $dN/dt$ vs. $N$; if the function crosses the $dN/dt = 0$ line (meaning that, at least momentarily, population is at equilibrium) with a positive slope, the dynamics pull the system away from that point. The reverse is true if it crosses with a negative slope.

### The mathematical rule of thumb

But now think back to our first-return plot. When did we define an equilibrium? When $N_{t+1} = N_t$. Previously we were interested in $dG/dN = 0$, meaning when functions crossed the x-intercept. Now we're interested in when functions cross the identity line, meaning that $G'(N) = 1$. This is also the criterion for stability in *all discrete-time models, not just the Ricker model:* if $|f'(\hat{N})| < 1$.

Revisiting the second derivative of the Ricker model at $\hat{N} = K$, $dG/dN = 1 - r$: \textcolor{green}{What values does r have to take on for this to be stable?} In other words, for what r is $|1-r| < 1$? Answer: r must be between 0 and 2.

### The graphical explanation

Let's try to build some graphical intuition for stability in discrete-time models, which have more complex behavior than continuous-time ones. We're again going to trace population dynamics from one moment to the next, but this time in the first-return plot. Let's start with a value of N a little above 0. Then we're going to:

-   Go vertically up to the curve. This gives us the next population size (at the x-value we picked, what's the y-axis value?)
-   Now let's re-consider that value to be our new x. How do we get from y to x on this plot? Go horizontally toward the 1:1 (identity) line. That translates the y you found (last time step's $N_{t+1}$) into an x (this time-step's $N_t$).
-   Repeat!

Drawing plots is getting harder in this class, but let's start with a low value of r, which means the peak of the Ricker curve is on the identity line. (Because this curve has a long tail we're going to stop drawing the axes on the same scales.) We know where the equilibria are: the question is, does the dynamics of the system pull us toward or away those two points?

```{r}
# Load necessary package
library(ggplot2)
library(gridExtra)

# Ricker function
ricker <- function(N, r, K) {
  N * exp(r * (1 - N / K))
}

# Cobweb function
make_cobweb <- function(r, K = 100, N0 = 10, steps = 50) {
  f <- function(N) ricker(N, r, K)
  N_vals <- numeric(steps + 1)
  N_vals[1] <- N0
  
  # Calculate the sequence of population values
  for (t in 1:steps) {
    N_vals[t + 1] <- f(N_vals[t])
  }
  
  # Store segments for cobweb path
  segments <- data.frame(x = numeric(), y = numeric())
  for (t in 1:steps) {
    # Vertical line (N_t, f(N_t))
    segments <- rbind(segments, data.frame(
      x = N_vals[t],
      y = N_vals[t + 1]
    ))
    # Horizontal line (f(N_t), f(N_t))
    segments <- rbind(segments, data.frame(
      x = N_vals[t + 1],
      y = N_vals[t + 1]
    ))
  }
  
  # Ricker curve for plotting
  N_seq <- seq(0, K * 2, length.out = 500)
  f_vals <- f(N_seq)
  
  # Build plot
  ggplot() +
    geom_line(aes(x = N_seq, y = f_vals), color = "steelblue", size = 1.2) +  # Ricker curve
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") +              # identity line
    geom_path(data = segments, aes(x = x, y = y), color = "darkred", size = 1) +  # cobweb
    labs(
      title = paste("Ricker Cobweb: r =", r),
      x = expression(N[t]),
      y = expression(N[t+1])
    ) +
    theme_minimal(base_size = 8)
}

# Create the three plots
p_stable <- make_cobweb(r = 1)     # stable convergence
p_oscillate <- make_cobweb(r = 2.2)  # oscillations
p_chaos <- make_cobweb(r = 4)      # chaos

# Combine into one panel
grid.arrange(p_stable, p_oscillate, p_chaos, ncol = 3)

```

We can see that $\hat{N}=0$ is always unstable because we are always drawing away from it, and the equilibrium $\hat{N}=K$ is very stable for low r. Let's draw out these diagrams for higher values of r. How on Earth do we interpret these cobweb diagrams? The second one eventually exhibits regular bouncing between the same population sizes. \textcolor{green}{What did we call that behavior earlier?} The third one never stabilizes and goes all over the place. \textcolor{green}{What did we call that behavior earlier?}

We know that the Ricker model equilibrium at $\hat{N}=K$ is stable for $0 < r < 2$. It turns out that r controls the steepness of the $N_{t+1}$ vs $N$ plot near the equilibrium point. (Remember that the second derivative was just $1-r$? That is the slope of the $N_{t+1}$ vs $N$ plot at the equilibrium! It only depends on r.) Thus, if r is small (and likely stable), the curve is not very steep when it crosses the identity line. We could have actually guessed whether the plots above would lead to stability without doing the cobweb diagrams!

To check our intuition, let's graph the exact same parameter values in N vs t space:

```{r}
library(ggplot2)
library(tidyr)
library(dplyr)

# Ricker function
ricker <- function(N, r, K) {
  N * exp(r * (1 - N / K))
}

# Shared parameters
K <- 100
N0 <- 10
steps <- 50

# Parameter sets
r_vals <- c(1, 2.2, 4)
labels <- c("Stable (r = 1)", "Oscillatory (r = 2.2)", "Chaotic (r = 4)")

# Simulate all three trajectories
df_list <- lapply(seq_along(r_vals), function(i) {
  r <- r_vals[i]
  N <- numeric(steps + 1)
  N[1] <- N0
  for (t in 1:steps) {
    N[t + 1] <- ricker(N[t], r, K)
  }
  data.frame(
    time = 0:steps,
    N = N,
    Model = labels[i]
  )
})

# Combine and plot
df_all <- bind_rows(df_list)

ggplot(df_all, aes(x = time, y = N, color = Model)) +
  geom_line(size = 1.2) +
  geom_hline(aes(yintercept=K), linetype="dashed", color='grey') + 
  labs(
    title = "Population Trajectories for the Ricker Model",
    subtitle = paste("K =", K, ", N0 =", N0),
    x = "Time (t)",
    y = expression(N[t]),
    color = "Model"
  ) +
  theme_minimal(base_size = 14)

```

This is also consistent with our mathematical condition for stability in the Ricker model above. When r gets too large, we see sustained oscillations and then chaos.

\textcolor{green}{Reflect and then share:} The only thing varying between these curves is r. Why would the value of r, biologically speaking, have such a big impact on population dynamics? Why would larger values of r lead to more complex behavior in a discrete-time model? What are some real-world populations that might exhibit this behavior?

## Chaos in ecology

That simple models in discrete time could yield chaotic dynamics at realistic values of r was a surprising discovery (see May, 1974). We now suspect that many systems have chaotic dynamics, particularly plankton systems (lots to read about this if you're interested.) \textcolor{green}{Reflect and then share:} If chaos is common in simple population models, what does that mean for the predictability of the real world?

# Age and stage structure 

\textcolor{green}{Discuss:} Up to this point we've been assuming all individuals in a population are the same. What are some ways in which that might not be true? What might vary among individuals, and how might that variation affect population dynamics?

### The loggerhead sea turtle scenario

Loggerhead sea turtles, *Caretta caretta*, are large marine reptiles found in the Atlantic, Pacific, and Indian Oceans as well as the Mediterranean. This species has a complex life cycle with very different behavior and reproductive activity by life stage. Females mate every 2-3 years and then nest on beaches close to where they themselves hatched. They do not tend to their eggs, which hatch after several months. Hatchlings then make their way to the water, where they disperse into the open ocean. As they grow larger they often reappear in coastal habitats, frequenting lagoons and estuaries. Females do not reach sexual maturity until they are around 35 years old. Loggerheads can live more than 80 years and are often over a meter long. 

As you can see, modeling loggerheads as a population of identical individuals who all reproduce at the same rate is probably a bad assumption. Also, loggerhead populations are generally declining worldwide. Their different life stages face very different threats. Adults are often killed by boat strikes, fishing gear entanglements, or marine debris. Habitat degradation is common in coastal areas, which is particularly harmful to species like loggerheads that return to the beaches where they hatched. Turtle sex is determined by the temperature during incubation, so climate change will likely alter the sex ratio of this species. Human activity on or near beaches poses a risk to eggs (which can be destroyed easily) and hatchlings (which may not reach the water, especially if they are disoriented by artificial light). 

## Matrix refresher 

A **matrix** is a rectangular array of numbers. For example, a $2 \times 3$ matrix has 2 rows and 3 columns:

$$
A = \begin{bmatrix}
1 & 4 & 2 \\
3 & 0 & 5
\end{bmatrix}
$$

We usually denote a matrix with uppercase letters (e.g., $A$, $B$), and its elements with lowercase letters and subscripts, like $a_{ij}$ for the element in row $i$ and column $j$.

- A matrix with $m$ rows and $n$ columns is called an **$m \times n$ matrix** (rows always go first!)
- A one-dimensional matrix is called a **vector** (this should sound familiar from computing) 
- A **column vector** is a matrix with size $n \times 1$
- A **row vector** is $1 \times n$

For example, a population vector tracking three age classes might look like:

$$
\mathbf{n} = \begin{bmatrix}
n_0 \\
n_1 \\
n_2
\end{bmatrix}
$$

Here, we aren't saying anything about *how to get from the matrix to a single number.* If we wanted to state **n** as the sum of the three age classes here we would just do that. Rather we're saying that this matrix *holds* entries for each age class. We're going to use matrices to track age-structured populations, because they're a tidy way to hold information about multiple ages (or stages) without transforming it (like summing it or averaging it, which we don't necessarily want to do---which is why we're moving away from calculating a single N). 

Now, let's refresh matrix operations. You can add or subtract matrices to/from one another **only if they have the same dimensions**. You add corresponding elements (matrix elements with the same position):

If

$$
A = \begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix}, \quad
B = \begin{bmatrix}
5 & 6 \\
7 & 8
\end{bmatrix}
$$

Then:

$$
A + B = \begin{bmatrix}
1 + 5 & 2 + 6 \\
3 + 7 & 4 + 8
\end{bmatrix}
= \begin{bmatrix}
6 & 8 \\
10 & 12
\end{bmatrix}
$$

Subtraction works the same way:

$$
A - B = \begin{bmatrix}
1 - 5 & 2 - 6 \\
3 - 7 & 4 - 8
\end{bmatrix}
= \begin{bmatrix}
-4 & -4 \\
-4 & -4
\end{bmatrix}
$$
The above is called **matrix addition or subtraction**. Mathematically, you aren't supposed to just add or subtract scalars (single values); i.e., $A + 5$ is an illegal operation because a matrix is an array of numbers and a scalar is not. You can do this operation in lots of programming languages though, and in practice it typically adds the scalar elementwise (separately to every element of the matrix, i.e., adding 5 to every value in A.)

**Matrix multiplication** is a little more complicated, so we'll split this into three parts: *matrix-scalar, matrix-vector, and matrix-matrix multiplication.* You can multiply a matrix by a single number (scalar) by multiplying **every entry** in the matrix:

If

$$
A = \begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix}
\quad \text{and} \quad
k = 5,
$$

then:

$$
kA = 5 \cdot A = \begin{bmatrix}
5 \cdot 1 & 5 \cdot 2 \\
5 \cdot 3 & 5 \cdot 4
\end{bmatrix}
= \begin{bmatrix}
5 & 10 \\
15 & 20
\end{bmatrix}
$$

This operation scales the entire matrix up or down. In this class, we'll be mostly using *matrix-vector multiplication*. If $A$ is a $3 \times 3$ matrix and $\mathbf{n}$ is a $3 \times 1$ column vector:

$$
A \cdot \mathbf{n} = \begin{bmatrix}
a_{00} & a_{01} & a_{02} \\
a_{10} & a_{11} & a_{12} \\
a_{20} & a_{21} & a_{22}
\end{bmatrix}
\begin{bmatrix}
n_0 \\
n_1 \\
n_2
\end{bmatrix}
= 
\begin{bmatrix}
a_{00}n_0 + a_{01}n_1 + a_{02}n_2 \\
a_{10}n_0 + a_{11}n_1 + a_{12}n_2 \\
a_{20}n_0 + a_{21}n_1 + a_{22}n_2
\end{bmatrix}
$$
Each new entry is a **linear combination** of the population across age classes. In other words, for square matrices, we take the ith element of the column matrix (i.e., ith row) and multiply each entry in the ith *column* of the matrix by that value. Then we *add all those values together.* For n-by-n square matrices multiplied by a n-by-1 column vector, after you do the addition for each element, you get back a n-by-1 matrix.  

## Age structure 

Hastings pp16-20, Caswell 8-18

If your goal was to conserve loggerhead turtles, in addition to chronicling their population dynamics enough to know they are declining, your next most-pressing question would probably be: **which of these life stage-specific threats is driving population decline, or would be most valuable to protect to help the species?** 

Loggerhead sea turtles have a pretty complex life cycle so we're going to introduce these models with a simpler example and come back to turtles later. To make this as easy as possible, we're going to assume that per capita birth rate and survival rate are not affected by the number of individuals (*no density dependence*). However, they ARE affected by age. 

\textcolor{green}{In the discrete-time, geometric growth case, how did we calculate R from counts of individuals observed from one time step to the next?}

In our simple example, let's assume that: 

* Our hypothetical organism lives for up to three years. We're going to call the individuals in their first year of life (0-364 days old) the "age 0 class",  individuals in their second year of life the "age 1 class" (just like humans: you are 1 until you turn 2), and so on. All age classes can reproduce, but their rates may differ. No individuals survive past 3, so there is no age class 3. 
* The population has two sexes, but we are only tracking and quantifying females. (This is a not-uncommon approach in population dynamics.) 
* Age 0 individuals have, on average, $f_0$ offspring per year (per capita). Age 1 individuals have, on average, $f_1$ offspring per year (per capita). Age 2 individuals have, on average, $f_2$ offspring per year (per capita). These f's stand for *fecundity* or *fertility*, which are basically technical terms for average offspring per year. 
* $p_0$ is the probability that a 0-year-old survives to become a 1-year-old. $p_1$ is the probability that a 1-year-old survives to become a 2-year-old. \textcolor{green}{(We don't need to specify a survival rate for age 2; why?)}
* $N_t$ is the total number of individuals at time t, and it is a single value (scalar). $N_t = \sum n(t)$, where $n_t = n_0(t) + n_1(t)$. Note that these are lowercase because they are *not* total population sizes and/or because they are vectors---none of them are the same as "big N". 

$n_0(t)$ is the number of offspring of 0-year-olds in year t plus the number of offspring of 1-year-olds in year t. \textcolor{green}{How would we calculate this, i.e., turn this statement into an equation?}

$n_1(t)$ is the number of 0-year-olds from time t-1 that survive to time t. \textcolor{green}{How would we calculate this?}

$n_2(t)$ is the number of 1-year-olds from time t-1 that survive to time t. \textcolor{green}{How would we calculate this?}

Conventionally we put t+1 on the left and t on the right (rather than t-1 and t). We could also denote these $n_{0,t}$ but we put t in parentheses because having everything in the subscript gets awkward when we are in t+1 land and beyond. 

$$
n_0(t+1) = n_0(t)f_0 + n_1(t)f_1 + n_2(t)f_2
$$

$$
n_1(t+1) = n_0(t)p_0
$$

$$
n_2(t+1) = n_1(t)p_1
$$

\textcolor{green}{Work out what the population size is at $t+1,t+2,t+3,t+4$ if the population at $N_t$ has (A) 10 age 0 individuals, no age 1 individuals, and 5 age 2 individuals or (B) no age 0 individuals, 10 age 1 individuals, no age 2 individuals. Hint: A table with rows for the age classes and columns for the time steps will help.}

The equations above can be written, much more conveniently, in matrix form. \textcolor{green}{As a group, try writing these down in matrix form, with population sizes at t+1 on one side and population sizes at t on the other.}

We start by just spelling out the vectors on both sides: 

$$
\begin{bmatrix} 
n_0(t+1) \\
n_1(t+1) \\
n_2(t+1)
\end{bmatrix} = \begin{bmatrix} 
(n_0(t)f_0 + n_1(t)f_1 + n_2(t)f_2) \\
n_0(t)p_0 \\
n_1(t)p_1
\end{bmatrix}
$$

We want to factor the right-hand side into a matrix multiplied by something. If we factor out the vector of population sizes, we get:

$$
\begin{bmatrix} 
n_0(t+1) \\
n_1(t+1) \\
n_2(t+1)
\end{bmatrix} = \begin{bmatrix} 
f_0 & f_1 & f_2 \\
p_0 & 0 & 0 \\
0 & p_1 & 0
\end{bmatrix}
\begin{bmatrix} 
n_0(t) \\
n_1(t) \\
n_2(t)
\end{bmatrix}
$$

The above is a convenient way to summarize the age-structured population dynamics. We can summarize this even more compactly by defining the matrix in the middle as **L**, which stands for Leslie matrix (one of the first people to utilize this model in ecology). Then we can state,

$$
n(t+1) = \mathbf{L}n(t)
$$

Matrix population models are generally classified by the form that **L** takes, and this is the simplest one---where **L** never changes. Nonetheless this sets us up to ask all kinds of questions about population dynamics! Your first one might be, will this age-structured population still exhibit exponential growth? It *looks* like it should, but recall that **L** is a matrix---not a scalar---and *n* is a vector. This model DOES tell us that *birth and death rates* are constant, but does that itself lead to exponential growth? 

Matrix models are so popular in population dynamics because they can be used to make projections of abundance across ages. Let's look at some examples.  

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# Define Leslie matrix: L[i, j] = transitions from age j to age i
# Example: 3 age classes
L <- matrix(c(
  1.2, 1.5, 0.5,  # fertility row
  0.6, 0,   0,    # survival from age 0 to 1
  0,   0.8, 0     # survival from age 1 to 2
), nrow = 3, byrow = TRUE)

# Define time steps
t_max <- 30

# Define multiple initial population vectors
initial_conditions <- list(
  `n0 = [10, 0, 0]` = c(10, 0, 0),
  `n0 = [0, 10, 0]` = c(0, 10, 0),
  `n0 = [0, 0, 10]` = c(0, 0, 10),
  `n0 = [10, 5, 2]` = c(10, 5, 2)
)

# Function to simulate population size over time
simulate_leslie <- function(n0, L, steps) {
  nt <- matrix(0, nrow = steps + 1, ncol = length(n0))
  nt[1, ] <- n0
  for (t in 1:steps) {
    nt[t + 1, ] <- L %*% nt[t, ]
  }
  # Return total population size at each step
  total <- rowSums(nt)
  data.frame(
    time = 0:steps,
    total = total
  )
}

# Run all simulations
results <- lapply(names(initial_conditions), function(label) {
  df <- simulate_leslie(initial_conditions[[label]], L, t_max)
  df$init <- label
  df
})

# Combine into one data frame
df_all <- bind_rows(results)

# Plot
ggplot(df_all, aes(x = time, y = total, color = init)) +
  geom_line(linewidth = 1.2) +
  labs(
    title = "Population Size Over Time",
    subtitle = expression(paste("Matrix model: ", bold(n)(t+1) == bold("L") %*% bold(n)(t))),
    x = "Time (t)",
    y = "Total Population Size",
    color = "Initial Population"
  ) +
  theme_minimal(base_size = 14)

```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# Define several Leslie matrices to compare
leslie_matrices <- list(
  "High fertility" = matrix(c(
    1.8, 1.2, 0.4,
    0.6, 0,   0,
    0,   0.8, 0
  ), nrow = 3, byrow = TRUE),

  "High survival" = matrix(c(
    1.2, 1.5, 0.5,
    0.9, 0,   0,
    0,   0.95, 0
  ), nrow = 3, byrow = TRUE),

  "Low fertility" = matrix(c(
    0.5, 0.7, 0.2,
    0.6, 0,   0,
    0,   0.8, 0
  ), nrow = 3, byrow = TRUE)
)

# Initial population vector (same for all scenarios)
n0 <- c(10, 5, 2)

# Time steps
t_max <- 30

# Function to simulate total population over time
simulate_leslie <- function(n0, L, steps) {
  nt <- matrix(0, nrow = steps + 1, ncol = length(n0))
  nt[1, ] <- n0
  for (t in 1:steps) {
    nt[t + 1, ] <- L %*% nt[t, ]
  }
  total <- rowSums(nt)
  data.frame(time = 0:steps, total = total)
}

# Run simulations for each Leslie matrix
results <- lapply(names(leslie_matrices), function(label) {
  df <- simulate_leslie(n0, leslie_matrices[[label]], t_max)
  df$matrix_label <- label
  df
})

# Combine into one data frame
df_all <- bind_rows(results)

# Plot
ggplot(df_all, aes(x = time, y = total, color = matrix_label)) +
  geom_line(linewidth = 1.2) +
  labs(
    title = "Population Size Over Time for Different Leslie Matrices",
    subtitle = expression(paste("All simulations use ", bold(n)[0], " = [10, 5, 2]")),
    x = "Time (t)",
    y = "Total Population Size",
    color = "Leslie Matrix"
  ) +
  theme_minimal(base_size = 14)

```

Several observations here. First---yes, this model does lead to exponential growth, even with age structure. However, both the initial population sizes and the Leslie matrix parameters affect the rate of exponential growth. Let's think more about the properties of this matrix:


$$
\begin{bmatrix} 
n_0(t+1) \\
n_1(t+1) \\
n_2(t+1)
\end{bmatrix} = \begin{bmatrix} 
f_0 & f_1 & f_2 \\
p_0 & 0 & 0 \\
0 & p_1 & 0
\end{bmatrix}
\begin{bmatrix} 
n_0(t) \\
n_1(t) \\
n_2(t)
\end{bmatrix}
$$

A few things to notice about the Leslie matrix:

* Birth rates, or fecundity, are always in the first row. 
* The subdiagonal contains survival fractions, or probabilites. 
* The other entries are all zero.
* n-by-n Leslie matrices have n eigenvalues and n eigenvectors. 

These things hold for **all age-structured population models, regardless of the number of age classes, or whether we make b or s conditional on other stuff.** (They are not true for stage-structured models, which we'll get to later.) What additional stuff could b or s be conditional on? They could be driven by the environment, 

$$
n(t+1) = \mathbf{L_t}n(t)
$$

Or by the population itself (i.e., density dependence). 


$$
n(t+1) = \mathbf{L_n}n(t)
$$

You can imagine turning some or all of the elements of **L** into functions of population size and the environment. You could certainly make an argument that both birth and survival have a density dependence, either positive (Allee effects) or negative (logistic growth). We're not going to go that far in this class. Matrix population modeling is a whole class and field unto itself, adhering closely to Hal Caswell's phenomenal book on the topic. It also requires linear algebra techniques that not everyone came into this class with. But I very highly recommend that book if you are interested in learning more. We are going to unpack a few more properties of the simplest (exponential growth) model, and then discuss stage structure. 

### Dominant eigenvalues and eigenvectors 

One thing we might want to do, similar to when we studied geometric growth in discrete time without age structure, is get a general function for $n(t)$ as a function of the initial population size $n(0)$. This allows us to explore age structure mathematically without stepping through every generation one at a time. Without age structure, we had $N(t+1) = RN_t$ and solved this to find that $N(t) = R^tN_0$. Similarly, here, we have $n(t+1) = Ln(t)$ and can deduce that $n(t) = \mathbf{L}^tn(0)$. (Convince yourself of this by looking at the equations above.) 

From here, we want a simple expression for $\mathbf{L}^tn(0)$ in terms of the parameters of the Leslie matrix that we can use to understand this model better. In particular, for large values of t, it would be nice to not have to figure out what L is raised to a large exponent. To simplify this, we will now take advantage of a property of n-by-n Leslie matrices, which is that they have n eigenvalues and eigenvectors. We will denote these $\lambda$ and 
$\overrightarrow{n}$. If this doesn't sound familiar to you from linear algebra, or even if it does, here's how they are defined: for a n-by-n matrix **M**, there are at most n (and for Leslie matrices, *exactly* n) sets of scalars and vectors for which the following is true:

$$
\mathbf{M} \overrightarrow{\mathbf{v}} = \lambda \overrightarrow{\mathbf{v}}
$$

Remember, we can't just divide both sides by v, which is a column vector. In this class we won't get into actually *finding* eigenvalues and eigenvectors, but we will use them to gain inference into age- and stage-structured models. 

Here, you need to know a little trick of eigenvectors. For a set of eigenvectors, e.g., $\overrightarrow{\mathbf{v_1}} = \begin{bmatrix}1 \\0 \end{bmatrix}$ and $\overrightarrow{\mathbf{v_2}} = \begin{bmatrix}0 \\1 \end{bmatrix}$, you can state any arbitrary vector $\mathbf{x}$ as $\mathbf{x} = a_1\overrightarrow{\mathbf{v_1}} + a_2\overrightarrow{\mathbf{v_2}}$, where $a_1, a_2$ are constants you can solve for computationally. 

We care about this rule because it makes the equation above, $n(t) = \mathbf{L}^tn(0)$, much more tractable. Let's call the eigenvectors of **L** $\overrightarrow{\mathbf{v_1}}, \overrightarrow{\mathbf{v_2}}, \overrightarrow{\mathbf{v_3}}$ and the eigenvalues $\lambda_1, \lambda_2, \lambda_3$. Recalling that $n(0) = [n_0 + n_1 + n_2]$, we can say that 

$$
n(0) = a_1\overrightarrow{\mathbf{v_1}} + a_2\overrightarrow{\mathbf{v_2}} + a_3\overrightarrow{\mathbf{v_3}}
$$
Substituting this in gives us 

$$
n(t) = \mathbf{L}^tn(0) = \mathbf{L}^t(a_1\overrightarrow{\mathbf{v_1}} + a_2\overrightarrow{\mathbf{v_2}} + a_3\overrightarrow{\mathbf{v_3}}) = \mathbf{L}^ta_1\overrightarrow{\mathbf{v_1}} + \mathbf{L}^ta_2\overrightarrow{\mathbf{v_2}} + \mathbf{L}^ta_3\overrightarrow{\mathbf{v_3}}
$$

And recall that above we defined the eigenvalue as the $\lambda$ for which **M v = $\lambda$ v**? We can therefore substitute:

$$
n(t) =  \mathbf{L}^tn(0) = a_1\lambda_1^t\overrightarrow{\mathbf{v_1}} + a_2\lambda_2^t\overrightarrow{\mathbf{v_2}} + a_3\lambda_3^t\overrightarrow{\mathbf{v_3}}
$$

Now, all of a sudden, we have the entire right-hand side of this equation expressed in terms of constants except for t. All we need to do is raise $\lambda$ to t. \textcolor{green}{As t gets large, what single value in this equation drives the population size?}

It's the biggest $|\lambda|$---the **dominant eigenvalue**, which is often denoted $\lambda_1$. As time goes on, $n(t) \approx a_1\lambda_1^t\overrightarrow{\mathbf{v_1}}$. This tells us that a single eigenvalue drives the long-term population growth (or decline) rate, and encodes a combined effect of birth and death. **When $\lambda$ < 1, the population is declining exponentially/geometrically; when $\lambda > 1$, it's increasing.** 

\textcolor{green}{Assuming you could calculate the eigenvectors, eigenvalues, and coefficients, what kind of biological questions could you explore with this model? }

### Stable age distribution 

We talked about the intuition behind the dominant eigenvalue: it determines long-term population change and approximates the combined effect of birth and death. What's the intuition behind the associated eigenvector, $\overrightarrow{\mathbf{v_1}}$? 

It turns out that in a scenario like the on we've been exploring---with constant birth and death rates given by **L**, that do not change over time---the population approaches a *stable age distribution.* This is actually a corollary of the population having a unique, constant growth rate that is not dependent on time or population size. For this to be the case, each age class must also have a constant growth rate---i.e., must make the same *per capita* contribution to the population every year. The growth rate would not be constant from one year to the next if the relative contributions of, for example, age 0 and age 1 individuals changed. 

This is NOT THE SAME as a stable population size; as we saw in the plots earlier, these populations will exhibit exponential growth or decline. However, as they grow away from the initial conditions, they will move toward a constant *ratio of age classes*. **This is the stable age distribution, and it is given by $\overrightarrow{\mathbf{v_1}}$.** 

Again, while this model doesn't actually describe many real-world populations, it can be helpful to delve into the stable age distribution to understand which life stages dominate long-term dynamics and how deviations from the stable age distribution arise and affect long-term dynamics. The Hastings textbook goes into detail on how this stable age distribution arises and demonstrates mathematically why it's stable; I'll skip this but feel free to look it up. 

```{r}
# Load libraries
library(ggplot2)
library(tidyr)
library(dplyr)

# Leslie matrix: 3 age classes
L <- matrix(c(
  1.2, 1.0, 0.5,  # fecundity row
  0.6, 0.0, 0.0,  # survival from age 0 to 1
  0.0, 0.7, 0.0   # survival from age 1 to 2
), nrow = 3, byrow = TRUE)

# Initial population NOT in stable structure
N0 <- c(100, 20, 5)  # mostly young

# Project forward
steps <- 30
N_mat <- matrix(NA, nrow = 3, ncol = steps + 1)
N_mat[, 1] <- N0

for (t in 1:steps) {
  N_mat[, t + 1] <- L %*% N_mat[, t]
}

# Convert to proportions (age structure)
age_props <- apply(N_mat, 2, function(N) N / sum(N))

# Put into data frame for plotting
df <- as.data.frame(t(age_props))
colnames(df) <- c("Age_0", "Age_1", "Age_2")
df$Time <- 0:steps

df_long <- pivot_longer(df, cols = starts_with("Age"), names_to = "Age", values_to = "Proportion")

# Plot
ggplot(df_long, aes(x = Time, y = Proportion, color = Age)) +
  geom_line(size = 1.2) +
  labs(
    title = "Convergence to Stable Age Distribution",
    x = "Time (t)",
    y = "Proportion in Each Age Class"
  ) +
  theme_minimal(base_size = 14)

```

## Stage structure 

After all this, we still aren't quite ready to build a model of the loggerhead sea turtle. That's because we've been talking about age structure, but with turtles (and many species), what really matters is *stage structure*---how many individuals are at each life stage. These aren't the same thing. Recall how turtles can be reproductive adults for decades, but their habitat use changes a lot early in life? Not only are life stages important, but turtles stay at them for multiple years, and different durations depending on the stage. We could build a giant matrix for every possible age of turtles, but we also often don't *know* their age, only their stage. (This is true for many surveyed populations). 

To model stage structure we introduce a little more complexity to our matrix models (Caswell pp56-). The easiest way to start understanding this is graphically. Let's sketch a diagram of the population we described above. 


```{r}
webshot::install_phantomjs()
library(DiagrammeR)

grViz("
digraph lifecycle {

  # Layout: left to right
  graph [layout = dot, rankdir = LR]

  # Node styling
  node [shape = circle, fontname = Helvetica, fontsize = 14]

  # Nodes (stages)
  A0 [label = 'Age 0']
  A1 [label = 'Age 1']
  A2 [label = 'Age 2']

  # Arrows: survival & growth
  A0 -> A1 [label = 'p0']
  A1 -> A2 [label = 'p1']
  
  # Arrows: stasis
 # A0 -> A0 [label = 'P₁']
 # A1 -> A1 [label = 'P₂']
  #A2 -> A2 [label = 'P₃']
  
  # Arrows: fecundity (reproduction into S1)
  A1 -> A0 [label = 'f1']
  A2 -> A0 [label = 'f2']

}
")
```

This is a graphical representation of the population model we wrote down in our simplest example. \textcolor{green}{What key change do we need to make to transition to a stage-structured model?}

In a stage-structured model, individuals don't transition states (the big circles) in every time step. Some of them will move on to the next stage, but a proportion of them will stay at the same stage. (In Caswell's book, he calls these "size classes", because that's often how we measure them---especially in natural resource applications, like fisheries and forestry.) To describe this, we need to introduce another set of parameters: $g_0, g_1$, etc., which represent the probability an individual *survives and grows to the next stage.* (We still also have $p_0, p_1$, etc. in this model; those now represent the probability that an individual *survives and stays at the same stage.*) Note that these don't sum to 1, because there are a bunch of individuals that die in every time step. In all of our discussions of stage-structured models, we'll assume that individuals can't skip stages; to get from stage 0 to 2, they have to go through 1 first. 

\textcolor{green}{Try adapting the figure above to include this additional complexity, for a population with three stages but a lot of ages. Start by re-labeling the circles stages, not ages, and then think about how to add or change arrows. }



```{r}

library(DiagrammeR)

grViz("
digraph lifecycle {

  # Layout: left to right
  graph [layout = dot, rankdir = LR]

  # Node styling
  node [shape = circle, fontname = Helvetica, fontsize = 14]

  # Nodes (stages)
  A0 [label = 'Stage 0']
  A1 [label = 'Stage 1']
  A2 [label = 'Stage 2']

  # Arrows: survival & growth
  A0 -> A1 [label = 'g0']
  A1 -> A2 [label = 'g1']
  
  # Arrows: stasis
  A0 -> A0 [label = 'p0']
  A1 -> A1 [label = 'p1']
  A2 -> A2 [label = 'p2']
  
  # Arrows: fecundity (reproduction into S1)
  A1 -> A0 [label = 'f1']
  A2 -> A0 [label = 'f2']

}
")
```

Now do you see the advantage of stage-structured models? This could be an organism that lives for 50 years, but so long as we can identify the life stages *that have different birth, death, growth, or other vital rates,* we can vastly simplify the model. In the textbook there's an example of an actual stage-structured model for killer whales. They have four life stages. Stage 0 lasts for less than a year, so there is no probability of staying in that stage. Killer whales only reproduce in stages 1 and 2. \textcolor{green}{Try drawing a life cycle graph of this killer whale population model.}

Now let's move onto the matrix representations of these models. We can still state that $\mathbf{n}(t+1) = \mathbf{An}(t)$. The only difference from the age-structured example above is that the matrix is slightly different (see below) and $\mathbf{n}$ is now a vector of *stage* abundances (not age). 

How do we get this matrix? First of all, it will be a n-by-n matrix, where n is the number of stages. You can actually populate the entire matrix from the diagrams we've drawn. The element $a_{i,j}$ is given by the arrow in our life cycle graph from stage j to stage i. (The direction is important here; it's j --> i, not i --> j.) \textcolor{green}{For the three-stage example, try filling in **A.**}


$$
\begin{bmatrix}
a[1,1] = p_0 & a[1,2] = f_1 & a[1,3] = f_2 \\
a[2,1] = g_0 & a[2,2] = p_1 & a[2,3] = 0 \\
a[3,1] = 0 & a[3,2] = g_1 & a[3,3] = p_2
\end{bmatrix}
$$

This is, again, a Leslie matrix. It still has fecundities in the first row. Now, the subdiagonal contains transition probabilities (individuals that survive and grow to the next stage) and the diagonal contains probabilities of surviving and staying at the same stage. We are now, at last, ready to build a stage-structured population model of loggerhead sea turtles! Crouser et al. 1987 actually did this---a large improvement over previous, age-structured models of loggerheads. \textcolor{green}{Do you think it was reasonable for them to fit a model without density dependence or enviromental effects---i.e., a constant growth rate model---to this population? Why or why not?} 

They estimated a $\lambda$ around 0.945; \textcolor{green}{Does this mean the population was increasing or decreasing?} They then calculated the stable age distribution (dominant eigenvector), the relative reproductive contributions of each age class at the stable age distribution, and then simulated how $\lambda$ would change if mortality at each life stage either increased or decreased drastically (representing human impacts or conservation measures). They found that the most sensitive life stages were juveniles and subadults: reducing mortality on those would tip the population into a growth phase, and increasing mortality on those would cause rapid collapse. This and a follow-up paper, Crowder et al. 1994, demonstrated that a popular conservation strategy for sea turtles---protecting nesting beaches and hatchlings---was much less effective than reducing at-sea mortality of juvenile and subadult sea turtles. This set of studies was extremely influential and led to the widespread adoption of "turtle excluder devices". 

# Metapopulations 

As this course has progressed we've chipped away at the unrealistic assumptions in our simplest models. Because per capita population growth is unlikely to be constant, we introduced negative density dependence (logistic model) and positive density dependence (Allee effects). We also modeled the effects of time lags, both in the continuous-time delayed logistic model and in the discrete-time Ricker model, and saw how complex dynamics can quickly arise in those models. Next, we tackled the assumption that all individuals in a population are identical, and saw how we can track population dynamics across age or stage classes separately, allowing them to have different rates of fecundity, growth, and death. 

The next assumption we will tackle is that populations are homogenous and perfectly mixed across *space.* Just as individuals (or groups of individuals) have different vital rates at different ages and life stages, individuals or populations may have different vital rates in different *places*. \textcolor{green}{What are some reasons why this might be the case?}

The simplest way to build this into population models is to say that rather than a single population where all individuals (of the same age / stage) are identical and can reproduce with one another, we say that there is *a set of those populations*---a **metapopulation,** or a "population of populations." We call each place occupied by one of those populations a "patch." 

The biggest difference between metapopulation models and population models is that the latter describes *abundance,* or $N$, and the former describes *persistence.* Metapopulation models are commonly applied to understand the relationship between changing habitat and local extinction, or "extirpation." We don't apply them to think about how many individuals are in a patch (we can use conventional population models for that) but rather to understand what proportion of an available landscape or seascape is being occupied by any population. 

Hastings only spends one page on this, so I'm instead using the introduction to metapopulations from Gotelli (Chapter 4) as well as Marissa Baskett's ESP121 notes here. 

## The simplest model of patch dynamics

Every patch has two states: empty or occupied. A patch becomes empty due to local extinction, and it becomes occupied due to immigration. The quantity we are interested in tracking is $p$, the fraction of occupied patches (ranges from 0 to 1). In this simplest model, let's say that all patches have the same rate of extinction (e) and immigration (m). Then:

$$
\frac{dp}{dt} = immigration - extinction
$$

In words, the *rate of change of p over time* is driven by the immigration rate minus the extinction rate. [Draw a metapopulation on the board and define p.] We define the extinction rate as e and the immigration rate as i (some textbooks use m, which can also mean mortality, which is why I'm using i). Immigrants come from an occupied patch, and can only go into an unoccupied patch. Extinctions can only happen in occupied patches. Thus, we can write this equation as:

$$
\frac{dp}{dt} = ip(1-p) - ep = p(i(1-p) - e)
$$

### Equilibria and stability 

Remember how in our first population model, we said that the rate of population change over time was equal to births minus deaths? This is an analogous model, except rather than continuous turnover of individuals, there is continuous turnover of occupied patches. Just as logistic (well, all) population models are stable when births equal deaths, metapopulation models are stable when immigration equals extinction. \textcolor{green}{How would we find the equilibrium where immigration equals extinction in this case? Take a few minutes to solve the below.}

$$
0 = p(i(1-p) - e)
$$

We find two equilibria: $\hat{p} = 0$, i.e. extinction, or $\hat{p} = 1 - e/i = \frac{i-e}{i}$. Let's analyze these equilibria for stability. Once again, if $dp/dt = G(p) = 0$ it tells us about equilibria, and whether $G'(p)$ is positive or negative tells us about stability. So let's take the derivative of this equation. 

$$
G'(p) = \frac{d}{dp} ip(1-p) - ep = \frac{d}{dp} ip - ip^2 - ep = i - 2ip - e
$$

Substituting in our first equilibrium, $\hat{p} = 0$, gives us $i - e$. \textcolor{green}{Remember that the equilbrium will be stable if this value is negative. When is it negative? When is it positive? When is it zero? Is it a good thing or a bad thing if the equilibrium at $\hat{p} = 0$ is stable?} 

Now let's do the equilibrium at $\hat{p} = \frac{i-e}{i}$. 

$$
i - 2i(1-e/i) - e = i - 2i + 2ie/i - e = -i + 2e - e = e - i
$$

This is stable (negative) when i > e. We could have guessed this by thinking more deeply about the $\hat{p} = 1 - e/i$ equilibrium condition: for it to lead to persistence, we'd need p > 0, or $\frac{i-e}{i} > 0$; this can be simplified to $i-e>0$, or $i>e$. This should make intuitive sense. Note that this condition doesn't mean that p goes to 1; it goes to a value determined by the ratio of extinction to immigration (aka colonization).

Finally, let's draw metapopulation dynamics and see the parallels with logistic population growth. 

```{r}
library(deSolve)
library(ggplot2)
library(dplyr)

# Metapopulation model
metapop_model <- function(t, state, parameters) {
  p <- state[1]
  with(as.list(parameters), {
    dp <- p * (i * (1 - p) - e)
    list(c(dp))
  })
}

# Parameter combinations
params_list <- list(
  list(i = 0.05, e = 0.02),
  list(i = 0.05, e = 0.05),
  list(i = 0.05, e = 0.08),
  list(i = 0.1,  e = 0.02),
  list(i = 0.1,  e = 0.08)
)

# Simulation time
times <- seq(0, 50, by = 0.1)
p0 <- c(p = 0.1)

# Simulate all parameter combinations
simulations <- lapply(params_list, function(pars) {
  out <- ode(y = p0, times = times, func = metapop_model, parms = pars)
  as.data.frame(out) |>
    mutate(i = pars$i, e = pars$e)
})

df_all <- bind_rows(simulations)

# Plot p vs t
ggplot(df_all, aes(x = time, y = p, color = interaction(i, e))) +
  geom_line(size = 1.1) +
  labs(
    title = "Metapopulation Dynamics (p vs t)",
    x = "Time (t)",
    y = "Fraction Occupied (p)",
    color = "i and e"
  ) +
  theme_minimal(base_size = 14)

```

```{r}
# Plot dp/dt vs p for a few i and e combinations
dp_dt_curve <- function(p, i, e) {
  p * (i * (1 - p) - e)
}

p_vals <- seq(0, 1, by = 0.01)

# Parameter sets to show
param_grid <- expand.grid(
  i = c(0.05, 0.1),
  e = c(0.02, 0.08)
)

# Evaluate dp/dt
df_dp <- param_grid |>
  rowwise() |>
  do({
    data.frame(
      p = p_vals,
      dpdt = dp_dt_curve(p_vals, .$i, .$e),
      i = .$i,
      e = .$e
    )
  })

# Plot
ggplot(df_dp, aes(x = p, y = dpdt, color = interaction(i, e))) +
  geom_line(size = 1.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(
    title = expression("Rate of Change" ~ (dp/dt) ~ "vs Occupancy (p)"),
    x = "Fraction Occupied (p)",
    y = expression(dp/dt),
    color = "i and e"
  ) +
  theme_minimal(base_size = 14)

```

## Case study: marine reserves  

Now that we've seen how metapopulation dynamics in this simple model are analogous to logistic growth---where the fraction occupied, p, eventually stabilizes, and dp/dt goes to 0---let's add in some more complexity to resemble a marine ecosystem. To do this, we'll build from a paper entitled "Role of marine reserves in recruitment to reef fisheries: A metapopulation model" (Man *et al.* 1995 *Biological Conservation*). They start with our same definitions as above, where p is the proportion occupied; extinction is e, and the proportion of occupied patches decreases at a rate $ep$; and propagules move from occupied patches to empty ones, giving an immigration rate $ip(1-p)$. (Note that the paper uses m where we use i; I chose this notation because m also can mean mortality, so I think the paper's notation is confusing.) Thus, again, 

$$
dp/dt = ip(1-p) - ep
$$

Man et al. make three key modifications to make this model more realistic for marine reserve planning and harvested populations. First, not all patches are equal. Some proportion of them, $q_1$, are marine reserves (no fishing or other human uses), and another proportion ($q_2$) is fished; $q_1 + q_2 = 1$. This is the main management lever of the fishery; managers can increase or decrease $q_1$. (This might sound simplistic, but it is actually a common management strategy in many parts of the world, especially data-limited settings. If you're curious about some ways this can work, read more about "territorial use rights for fishers".) In their model, exploitation (fishing) affects $e$, but not $m$. Thus they define a new $e_1$ (unfished) and $e_2$ (fished) and assume that $e_2$ is much, much bigger. (Remember last week we talked about early marine reserve theory using the "scorched earth hypothesis"---that everything dies outside of the protected area?)

Next, they also divide up tracking persistence into $p_1$ and $p_2$. Being natural resource managers, they're really curious about $p_2$: how can you keep a viable population in the exploited areas just by turning the dial of "how much habitat is protected"? They do assume that individuals are equally likely to go from any occupied patch into any other occupied patch, fished or unfished, so there is just one $i$ value to track here. Let's try to derive our two equations for $dp_1/dt$ and $dp_2/dt$. 

Looking at our differential equation for $dp/dt$ without any marine reserve extensions, we see there are three parts: $-ep$, which deals with extinction from occupied patches; $ip$, which tells us the rate at which individuals immigrate from occupied patches; and $1-p$, which scales that down so that only empty patches are being colonized. For marine reserves, adapting $-ep$ is straightforward; we just have $-e_1p_1$. Adapting $ip$ is also straightforward; i is still a single constant that applies to offspring produced everywhere (in either patch type), so this just becomes $i(p_1+p_2)$. How do we adjust the term $(1-p)$ to represent *only available patches that are in marine reserves*? Fortunately, we defined a quantity for this! To figure out what proportion of patches in marine reserves are unoccupied, we just take $q_1-p_1$. So this becomes 

$$
dp_1/dt = i(p_1+p_2)(q_1-p_1) - e_1p_1
$$

And the exact same equation for exploited patches, because the production of offspring is the same everywhere (the first term, $i(p_1+p_2)$); we scale that down by what proportion of exploited patches are occupied, $q_2-p_2$; and then subtract out the extinction rate in this patch type. 

$$
dp_2/dt = i(p_1+p_2)(q_2-p_2) - e_2p_2
$$

They then make a third assumption, which is that $e_1 = 0$. In other words, for harvested populations, none of them die in marine reserves. \textcolor{green}{Do you think this is true?} (They also rearrange some terms in the $dp2/dt$ equation which isn't important here.) The authors add that ideally these equations would include a time lag between the recruitment process of larvae or juveniles, i, and the process of "aging into the fishery", which is when they start counting p. They note that is computationally intractable, which I'm sure it was in 1995, but it isn't now! 

Let's find the equilibrium value for $\hat{p_1}$ with the simplified equation, $dp_1/dt = i(p_1+p_2)(q_1-p_1)$. When does $dp_1/dt = 0$? What does that tell us about the long-term dynamics of this system? 

### Modeling the benefits of marine reserves to fisheries 

In the paper they find the equilibrium value for $\hat{p_2}$; we won't go through the math for this. But I do want to highlight how these fairly simple equations can inform strategic decisions about marine spatial planning. The best way to do this is a figure from the paper, which I'll attempt to re-draw. 

![Figure 2 from Man, Law, and Polunin 1995. The intensity of fishing (c, which scales with $e_2$ and is defined as $e_2/i$) modulates the relationship between how much habitat is in marine reserves ($q_1$, x-axis) and the equilibrium proportion of occupied patches in harvested areas ($p_2$, y-axis). Dots represent the protection level that maximizes occupied areas available to fishing for a given rate of fishing mortality.](metapopulations_marine_reserves_man_bio_cons_1995.png). 

This implies that if fishing mortality ($e_2$ or c) is low, there's no reason for any habitat protection. The highest occupancy rate in harvested areas occurs when zero habitat is protected. But as fishing mortality increases, the marine reserves start to serve a role in producing "spillover" to the harvested areas---and you see that for very high fishing mortality rates, *if no habitat was protected, this model predicts total extinction outside of marine reserves.* 

Now, there are a lot more extensions that would make this model more realistic. \textcolor{green}{If you really wanted to know how much habitat to protect to maximize fisheries benefits, what else would you need to know?}

As an interesting coda, whether marine reserves increase fish biomass *in total* is still a huge area of debate. \textcolor{green}{Why do you think this has been so difficult to prove?}

The marine reserve population modeling literature is large, and the early classics are well worth a read, including: 

- Botsford, Hastings, and Gaines 2001. Dependence of sustainability on the configuration of marine reserves and larval dispersal distance. *Ecology Letters.*
- Guichard *et al.* 2004. Toward a Dynamic Metacommunity Approach to Marine Reserve Theory. *BioScience.* 

# Spatial population modeling 

Metapopulation models don't quantify abundance, just persistence throughout the patch network (so they also don't track individual patches). Let's say we want to track actual abundance, but still incorporate some spatial structure to our population models. It turns out that you're already able to do this---and it's a chance to start blending together the modeling approaches we've been learning. Let's work through the equations on our own. We assume:

- Discrete time, logistic growth dynamics
- Two adjacent patches, indexed A and B 
- Three age classes. Age 0 is recruits; they don't do anything except age and die (at a constant rate, $s_0$. Age 1 is juveniles; they don't reproduce but are highly mobile. Age 2 is adults; they don't move, but they do reproduce *at a patch-specific rate*, $f_A$ and $f_B$ (you can think of this as an environmental effect, although for now let's just leave it as a constant). 
- Movement happens between patches at a fixed rate, $d$, which stands for diffusion. 

\textcolor{green}{Together, let's write down a system of equations for the three age classes each year ($n_0(t+1)$ and so on).}

If we have time, discuss and try extending these equations to additional complexities, such as density dependence (possibly with a patch-specific carrying capacity), more than two patches, fishing mortality, etc. 

# Interacting populations

We've already started to write down equations for multiple age classes or life stages; multiple patches and populations; and multiple forms of population growth. Now and for the next few weeks, we're going to consider some models of multiple interacting species. 

First, I think it's worth interrogating---why do we need multispecies models at all? What can they capture that we couldn't represent with single-species models? \textcolor{green}{Try to come up with a list of ecological processes that we can't simplify down to exogenous effects on single poopulations.}

Core feature of multispecies models are:

- We are representing populations that are interacting, and 
- Those populations are from different species *with different relevant traits.* 

If the two populations have identical traits for all of the variables that matter, then we shouldn't care that they are from two species! For example, if we're modeling phytoplankton growth over time and every species has the exact same carrying capacity, intrinsic growth rate, and life history, then *it does not matter that they are different species* (or might have different, unrelated traits; maybe one is blue and one is pink). We could just model them jointly as one population. (Thanks are very much due to Chuliang Song at UCLA for fascinating conversations about this test for ecological models---if different species have identical traits, do they give the same results as if you modeled them as a single population?---at the 2025 American Society of Naturalists meeting in Asilomar, CA.)

So by extension, our goal here is to understand: what happens when populations of species with different traits interact? 

## Lotka-Volterra 

# Coexistence and competition: are species good or bad for one another? 

# Applications of population modeling to management and research

# Other topics to add:

-   R\*
-   Alternative stable states and hysteresis
-   Resilience, multiple stressors, ball-and-cup theory
